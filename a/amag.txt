THE ASSEMBLY LANGUAGE "MAGAZINE"                  VOL1 NUMBER1
                                                  FEBRUARY 20,1989

















  ##     ####    ####   ####### ##   ## ######  ####    ##  ##
 ####   ##  ##  ##  ##   ##   # ### ###  ##  ##  ##     ##  ##
##  ##  ###     ###      ## #   #######  ##  ##  ##     ##  ##
##  ##   ###     ###     ####   #######  #####   ##      ####
######     ###     ###   ## #   ## # ##  ##  ##  ##   #   ##
##  ##  ##  ##  ##  ##   ##   # ##   ##  ##  ##  ##  ##   ##
##  ##   ####    ####   ####### ##   ## ######  #######  ####
  
        ####      ##    ##   ##   ####  ##  ##    ##      ####  #######
         ##      ####   ###  ##  ##  ## ##  ##   ####    ##  ##  ##   #
         ##     ##  ##  #### ## ##      ##  ##  ##  ##  ##       ## #
         ##     ##  ##  ## #### ##      ##  ##  ##  ##  ##       ####
         ##   # ######  ##  ### ##  ### ##  ##  ######  ##  ###  ## #
         ##  ## ##  ##  ##   ##  ##  ## ##  ##  ##  ##   ##  ##  ##   #
        ####### ##  ##  ##   ##   ##### ######  ##  ##    ##### #######


















Written by and for assembly language programmers.



The Assembly Language "MAGAZINE"                        vol. 1, #1
(send in your title suggestions!)


For the month of February 1989, we have:

Introduction..................................3
Article Suggestions...........................4
What Started It...............................5
Review of the A86 Assembler...................7
FAST Memory Moves.............................8
     Source code..............................8
A Few Good Programs..........................11
Keyboard Trapping-How When and Where.........13
     Source code.............................15
Book Reviews.................................24
Guidelines for Contributors..................26


NOTE:  *** WE NEED CONTRIBUTORS! ***  Read Article Suggestions and 
Guidelines and start sending those articles in!



                        Special to Electronic Magazines                       


The source files included here are complete asm files and you only need to 
edit them out with a text editor and then assemble them.


Produced by Patrick & David O'Riva
Edited, arranged, sent, etc. by same

Always available at:  The AsmLang & CFS BBS
                        (408) 259-2223 (woof! 143/37)
                        2726 Hostetter Rd, San Jose, CA 95132

                        Assembly Language 'Magazine'

        In this, the first issue, the only editorial you are going to get is
this short introduction to the magazine and an even shorter one to myself.
        This is to be a publication devoted to Assembly language programming
and to the Assembly language programmer. At first look it might appear that
it is to be a pclone only forum, but that is not the intention or the desire.
My current system is pclone and therefore where I have begun, but the same
needs exist on other systems as well:  6502, 6800, 68000 and so forth.
If there is to be any restriction it would be in the direction away from
pure operating systems and into user visible applications, but that line is
far too hazy to consider.
        The hope is to present this 'magazine' monthly with a transmission
date of the 15th. If YOUR interest is not communicated to me by way of 
comments and article submissions this publication will evaporate immediately.
        Your editor is no one you would have heard about. My first program-
ming was done by setting toggle switches on the front of the machine and
hitting the enter button.  I have worked on operating systems and interfaces
on the 8088, Z80, 6800 and 6502.  I am currently disabled and some months my
productive time approaches  0 but with the cooperation of my son (an excellent
programmer) I hope to coordinate this far into the future.



                             Policy on Piracy

        As you well know programming is not easy. It is always time consum-
ing and often very tedious.  A good program is as creative as a book or a work
of art.  Even a bad program entails many man hours of effort.  This time 
should not be stolen from the authors.  With conventional marketing piracy is 
illegal.In Shareware the same moral obligations exist.  If we use it we should 


pay for it.  Many of the programs to be discussed I expect to be in this 
category.
        I don't generally recommend publication of source code unless it is
your intention to put it in the public domain, however illustrative pieces
in an article could be of benefit to us all.  No code not wholly written by
the author should be submitted.




                 Suggestions for articles to be submitted

Reviews of programs- Reviews are always interesting because they can save
                someone a great deal of time in checking out something that
                will not meet their needs.

Bugs and idiosyncrasies- Undocumented facts about common tools

COM vs EXE

How to write a good TSR

Math libraries- All about

What is a good user interface

Public key signatures and Encryption- no viruses in Shareware

Most anything else of interest to you


                                 The Beginning                                
This was sent out on the FidoNet 80XXX echo in December 1988. Enough favorable
replies were received to continue the project.

        I am interested in starting a national magazine devoted to the use of
assembly language. The principle aims would be as follows:

                Improving the skills and knowledge of us all

                Widening the awareness of the benefits of assembly

                Provide reviews of new tools

Is there a need for such a publication? In terms of mass readership, probably
not. But in the desires of the select group of people who program in assembly
I feel that there is.
        Magazine is really the wrong term. I don't think there is a term for
what this would likely have to be. If there was a large enough market for a
normal publication I'm sure one of the major publishers would have done it.
I foresee an electronic distribution possibly carried on the 80xx Echo then
those interested could print it out, copy it, and make it available to others
who would be interested. Eventually a more formal distribution might be
arranged if there were enough interest. If anyone reading this is interested
in contributing articles or just making comments I would like to hear from
you.


                       EDITORIAL (JUST TO SPARK CONTROVERSY)

        Higher level languages are primarily a method of producing software
useful for corporations, because it can be written and understood by pro-
grammers with little knowledge of the equipment. This work can then be
passed on to another after he leaves, and little is lost. This same work
can also be moved to another environment simply by changing compilers.
Complex programs can be written quickly (This may be a fiction) and sent to
market.
        This all sounds pretty good, right? No. The price that we have to
pay for this is far too high. The size of these programs is becoming absurd.
This forces users (and that's what we all are) into a continual quest for
larger memory. The major debugging programs available leave no room in a
512k pclone to fit the program being debugged. Spreadsheet and database
programs are as bad and get worse with every new release of an 'improved'
version.
        The main program we use continuously is a major offender this way.
DOS has grown almost geometrically and has come to occupy a significant
fraction of available memory while adding few (if any) improvements since
version 2.0 (the continuing standard of compatibility).
        This situation is bad enough, but it is just the tip of the real
damage done by the NECESSARY use of high level language by the leading
software companies. Speed-- the magic word in computing is so thoroughly
compromised that the hardware industry is just holding its head above the
morass.
        Within the last year I have tried the latest release of the
assembler package from a major software company. I'm sure you know which
one I mean, but I'd rather not use names at this time so I don't have to
strictly document my figures. It was significantly larger than the previous
version (though somewhat faster 35 seconds as opposed to 50 seconds on the
program I tested it with). It would not assemble my source code from the
previous version without a number of silly modifications. The involved
syntax this package has traditionally used has annoyed me since the first
version I purchased. About this same time I tried a shareware assembler that
supports largely the same functions though in slightly differing form to
reflect the preference of the author. I won't say that it was without
flaws. No program is. After *removing* the instructions that have so irritated 


me in the other I assembled the same program with this. It is a fraction
of the size (about 20k). It loaded itself, loaded and assembled my program,
delivered a complete COM file, and inserted some trivial error messages *into*
a copy of my original source file in ** 4 ** seconds. This is around the
same length of time it took the other assembler to load itself.
       The editor contained in the commercial package while very versatile, 
and using some very clever techniques to speed up the usage, the first
time I tried to load a file in I thought my poor machine had bombed and
I reset it, but then I noticed that the disk was being accessed and it even-
tually displayed my file. The same situation occurred when I asked it to
show me it's help file. The shareware editor I am using now allows me even
greater versatility, only occupies about 15% of the memory and I can be
editing my file long before the other one would have loaded itself. And it's
not even completely written in assembly.
        In summation, while high level language may have its place, it is
not in programs expected to have high usage or when speed or size are
significant factors. The end users need to be given a choice and shown the
difference between quality programming and the corporate programming (much
of it vaporware) that they are now being offered.




                            A86 Assembler Review

A86 is a full featured Assembler for the 8088 80286 8087 80287 v20 and v30
microprocessors. It is not fully MASM compatible, though it comes close 
(except in the area of macros - its macro support is quite strong but entirely 



different from MASM).  Some of its unique features are support of entirely 
local variables so that a new and unique name need not be thought up for each 
local jump. It synthesizes the move segment register to segment register moves 



with pushes and pops and has some interesting commands to jmp far on 
condition,using the inverse jshort instruction and a local label. This saves a 



good amount of typing and actually makes the code more readable. It is a tiny
program, less than 24k and the assembly speed is astounding. The claim is
1000 lines per second. It will directly produce a COM file, usually so quick-
ly you don't even need to pause in your typing. EXE files are also supported
but as the COM format is so simple I haven't really checked that out too
well, and the support is not complete. The documentation is good for the
operation of the assembler but it is not a tutorial in assembly language
programming.
         So much for the advantages. It is not MASM compatible. While it will
work with most MASM source files without macros, MASM will not accept an A86
file. Most of the formatting commands of MASM (the proc and assume statements)
are more or less ignored. The segment end statements are ignored, as a seg-
ment statement closes the current segment. This simplified syntax can greatly
reduce the amount of typing necessary in a program, but somewhat more care is
needed by the programmer.
         One of the worst flaws as I see it is the lack of support for in-
clude files though its acceptance of multiple command line modules and libr-
ary files partially makes up for this.
         Overall, this is a very high quality program but not to be con-
sidered if you require MASM compatibility. This is a shareware offering by
Eric Isaccson, available from most BBS's.
         There is a companion symbolic debugger D86 also available. 


MASM is a trademark of Microsoft Corporation




                      DMA Transfers for FAST Memory Moves                     

If you ever have the need for super fast moves of blocks of memory and you
can put up with a lot of restrictions in order to gain the speed there is a
method in the PC environment to move bytes at the rate of one every 3 clock
cycles. Compare that to the clocks for a rep movsb and then say that isn't
fast. This isn't for every programmer and it certainly isn't for every time
you need to move a few bytes.
         The DMA chip is a four channel device. Channel 0 is reserved for
refresh of memory that requires at least 256 consecutive bytes be read some-
where in memory at intervals less than about 4ms. The other three channels
are available for such things as transferring information to and from the
disk drives or the ports. Interesting trivia so far, but not very useful in
moving memory around. It gets worse. The 8259 DMA doesn't know anything about
segments. It only knows a 64k universe. This is where the Page registers come
in. The page registers decide which page (on 64k boundaries) the 8259 will
look at for any operation. There are not, as you might guess, 4 page 
registers,but only 2 plus a default. If it is not channel 1 or 2 then it uses 
the default register programmed as channel 3.
         A careful reading of the data sheet of the 8259 discloses that it is
capable of doing a memory to memory transfer but only between channels 0 and
1. That is why this method is a little tricky to use. In order to set up your
own parameters you have to disable the timer from asking for a DMA from chan-
nel 0 every x milliseconds and reconfigure the 8259 and assume the respon-
sibility for doing the memory refresh. It actually sounds worse than it is.
The configuring and re configuring of the 8259 doesn't take all that long, so
the time is made up after only moving a few tens of bytes, and if you move at
least 256 CONSECUTIVE bytes the memory refresh requirement is met for another
2 or 3 milliseconds. The page registers are taken care of by setting channels
1 and 3 to the same value.
         Given below is an example of a program I wrote just to test the
idea.  A lot of the setup is too complex to explain in this short article, but
if you are interested in checking it all out you will need a data sheet on
the 8259.  This worked nicely on my machine and should on most compatibles 
just the way it is.  With the not-so-compatible it may very well not.  I hope 
this listing is well enough commented so you can figure it out and make use of 


it sometime. 

`                                DMA SOURCE

PAGE 60,132
TITLE DMA MEMORY TO MEMORY
DMA      EQU 0
STACK       SEGMENT PUBLIC 'STACK'
     DB  32 DUP('STACK')
STACK       ENDS
DATA     SEGMENT PUBLIC 'DATA'
SOURCE      DW   08000H
TARGET      DW   09000H
NUMBER      DW   800H
INCDEC      DB   0
PAGER       DB   0BH    ;PAGE (O TO F)
FILL     DB 0    ;2 IF A FILL OP
DATA     ENDS
ASSUME      CS:CODE,DS:DATA,ES:DATA
CODE     SEGMENT PUBLIC 'CODE'
START:
     MOV AX,DATA
     MOV DS,AX
     MOV AX,0B800H
     MOV ES,AX
PAGE:
     MOV AL,PAGER ;PAGE TO OPERATE IN
     OUT 83H,AL
UNDMA:
     OUT 0DH,AL   ;MASTER RESET OF DMA
     MOV DX,03D8H
     MOV AL,1
     OUT DX,AL
     MOV AX,SOURCE     ;WHERE IS IT COMING FROM
     OUT 0H,AL
     MOV AL,AH
     OUT 0H,AL
     MOV AX,TARGET     ;WHERE TO PUT IT
     OUT 2H,AL
     MOV AL,AH
     OUT 2H,AL
     MOV AX,NUMBER     ;HOW MANY
     OUT 3H,AL
     MOV AL,AH
     OUT 3H,AL
     MOV AL,009H  ;ENABLE M TO M,COMPRESSED
     OR  AL,FILL  ;WILL BE 2 IF FILL OP
     OUT 8H,AL
     MOV AL,088H  ;BLOCK MODE, INC, READ
     OR  AL,INCDEC     ;WILL BE 20H IF DEC
     OUT 0BH,AL
     MOV AL,85H   ;BLOCK MODE, INC, WRITE
     OR  AL,INCDEC     ;WILL BE 20H IF DEC
     OUT 0BH,AL
     MOV AL,4    ;THIS IS THE REQUEST
     OUT 9,AL    ;DO IT
     MOV AL,9
     OUT DX,AL
RESET:      OUT  0DH,AL  ;THIS IS A MASTER RESET
     OUT 0CH,AL   ;RESET F/L F/F
     MOV AL,01
     OUT 0,AL
     OUT 0,AL
REINIT:  
     MOV AL,0
     OUT 83H,AL   ;MOVES REFRESH TO BASE PAGE
     MOV AL,0FFH
     OUT 1,AL
     PUSH   AX
     OUT 1,AL
     OUT 0BH,AL
     INC AL  ;MODE CHAN3
     OUT 0BH,AL
     PUSH   AX
     POP AX
     POP AX
     POP AX
     MOV AH,4CH
     INT 21H
CODE     ENDS
END      START
`




                        All Programs Small and Fast
                        ---------------------------

        The programs mentioned here are ones that I use regularly or have been
recommended to me by those whose opinion I trust. In the later case, I have
tried them but they just don't fit with the way I do things. You will notice
some obvious holes in this list. These are cases where I have found nothing
that I am pleased enough to pass on. Not all of them are written in assembly
but they still work well in an assembly programming environment. Most of them
are Shareware products, and while this is not by design on my part it is not
by chance either. They were written by talented programmers in a non-corporate
setting.

Xhelp

This is a TSR pop-up. It comes with a file containing the DOS 3.2 instruction
set (about 50 pages worth) and an IBM/ascii table. It will also accept and
integrate any other documents that you care to enter. It implements searches,
index, and table of contents. Place marker is maintained between pop-ups.
I resent its size, but it is fast and well implemented.

        Exwells Software Company
        7677 Oakport St Suite 110
        Oakland,CA 94621

CED

One of the command line editors. It has extended functions to make DOS com-
mands resident and other programs can be invoked with arguments as though
from a batch file with a specified synonym. Small and fast. Also works inside
programs that strictly use DOS editing functions keeping internal and external
commands separate. Shareware.


List

Version 6.3+. I don't think this needs much said. It is by Vern Buerg,is small
and fast. If you don't have it, get it! Shareware


TSR

A collection of TSR handling programs. The Mark records the machine state,
including vectors, environment, and most anything else it can. Release, looks
for the latest Mark and restores that machine state, then erases the Mark.
Thus any TSR's are removed completely. This is very useful for development
work.  Shareware.


Qedit

This is a full screen editor. It is small, super fast, has too many features
to begin to list. You can configure the keyboard any way you like it very
quickly and easily. 10 file concurrent editing, 99 nameable buffers etc.
One of the finest pieces of software available. Shareware.


Microspell

A spelling checker. Unbelievable speed, compatible with most word processors.
Supports auxiliary dictionaries and allows entries into the main dictionary.

        Trigram systems
        5840 Northumberland St.
        Pittsburgh,PA 15217
        412-422-8976


Assemblers

This is a blank entry. A86 comes very close to qualifying; it is small, fast
but is lacking some useful tools such as include files. I am still using
grudgingly predominantly MASM 4 but may switch over. TASM from Borland is
receiving some interesting comments, but is still large 97k, and not as fast
as it might be. I've also heard of PASM. A review of it would be greatly
appreciated.  Late break: OPTASM may be reasonable as well...


Word Processors

This is also a blank entry. ChiWriter by Horstman Software is decent. It
is versatile, easy, but large and slow. The big NAMES I've tried I have thrown
away in disgust. Target size: <40k, plus fonts. Should scroll at typematic
rate. 100k search <1 sec. Configurable command keys(!).




                         Getting User Input, Part One                         
                    
                                by David O'Riva                               

        Most of you are familiar with the various ways to read the
keyboard.  One can ask DOS, through interrupt 21H, and get keystrokes
coming from the keyboard (or from whatever device or file the user told DOS
to use instead of the keyboard).
        Alternatively, if you want to be sure that you're getting actual
*keyboard* input, and/or you want more information than DOS is willing to
provide, you can go through INT 16H:

                MOV     AH,0
                INT     016H                    ;get a key & scancode
                MOV     DX,AX                   ;save keystroke in DX
                MOV     AH,2
                INT     016H                    ;get shift state in AL

...would give you the key pressed, it's scan code, and the shift states in
effect at the time of the press.  Information on all the INT 16H modes is
available from many references, and we will not delve any deeper into that
here.
        Now, if you NEED to know exactly what the keyboard state is, or to
get a keystroke the micro-second it is pressed, or to interpret and act on
multiple keystrokes (for example: you're writing a game, and you want one
half of the keyboard to be controls for player 1, and the other half to be
controls for player two.) then you need an IRQ 1 trap.
        The following sequence of events occurs for every key that is
pressed:

* KEYPRESS *
IRQ 1 is pulled high
The 8259 interrupt controller halts the system and does an INT 09H
The BIOS code for INT 09H polls the keyboard for the scan code, converts
   the code into an IBM scan code, which is for the most part identical to
   the scan codes from the keyboard.
If the CTRL-ALT-DEL sequence was pressed, control is given to the warm boot
   code.  Other special keys are serviced (i.e. SYSREQ on ATs, soft turbo
   mode switches, etc...)
The keystroke is placed in the buffer, if there is room.
The INT 09H code resets the 8259 and leaves.
INT 16H (when called) pulls the keystroke out of the buffer and hands it to
the application, or to DOS, which hands it to the application.

        Note that the INT 09H code in BIOS will only respond to a
keyboard MAKE code, except for shift keys.  The keyboard itself handles
typematic repeating, except on PCjrs.

        An IRQ 1 server needs to be installed BEFORE the BIOS code, and
can respond in varying ways to keystrokes.  Here are some examples of IRQ 1
servers for specific tasks:
  
1. For HOT-KEY popup
  a) poll the keyboard, find out whether it's a MAKE or BREAK code
  b) if it's a BREAK code
    b1) is it the BREAK code for our hot-key?
    b2) if so, did we trap the make code?
    b3) if we did, clear the keyboard latch, reset the 8259, and leave.
  c) if it's a MAKE code
    c1) is it the MAKE code for our hot-key?
    c2) if so, are we allowed to pop up now? (you don't want to start
          multiple iterations of your popup program...)
    c3) if we are, set a flag to wait for the BREAK code, clear the
          keyboard latch and 8259, and start the popup.
  d) if it wasn't acted upon before, leave the keyboard latch and
     interrupt mask as they are and continue down the INT 09H chain.

2. For multiple-key trapping
   First, set up an array that corresponds to the keys you want to trap.

  a) poll the keyboard, find out whether it's a MAKE or BREAK code.
  b) if it's a MAKE code
    b1) is it one of the keys we want to know about?
    b2) if so, set the element in the array that corresponds to this key.
    b3) You will *usually* want to clear the KB latch and 8259 to prevent
          the BIOS keyboard buffer from overflowing...
  c) if it's a BREAK code
    c1) is it one of the keys we want to know about?
    c2) if so, clear the element in the array that corresponds to this key.
    c3) if you prevented the MAKE code from reaching BIOS, do the same for
          this BREAK code.
  d) if it wasn't acted upon, continue down the INT 09H chain
       (alternatively, you can trap a key other keys here, like your "end
       the game" key, and prevent ANY keystrokes from reaching BIOS.  This
       would prevent a CTRL-C from invoking DOS's critical-error handler,
       a CTRL-ALT-DEL from blowing the game if files are open, etc...)

  e) in your game's code, use the array to determine which keys are pressed
       and what to do.

        As you can see, this sort of trap can be extremely powerful.  The
only caveat is that this requires a very-compatible PClone.  And this may
not be that bad, since I know that at least two very large game companies
are using a method similar to this for their games.
        Included with this article is a program called SHOWKEY.ASM, which
installs an IRQ 1 trap and prints on the screen the scan code that it
received from polling the keyboard, the current shift state, and the key
and scan code that a call to INT 16H returned (dashes are printed if the
key was not passed to the buffer).  The only thing I ask in relation to
this code is that if you distribute it unmodified, you leave my copyright
message in.  The code should be commented well enough that it is
understandable.

        Next month:  Pop-up TSR'S.  How to write, how to invoke, how to run,
how to remove from memory.  Watch for it!

        NOTE:  This is my first effort at writing an article for
programmers on a complicated subject.  Any comments or suggestions on
writing style or clarity of explanation would be welcomed.  Send to FidoNet
node 143/37 - Dave.


`               PAGE    60,132
                TITLE   SHOWKEY - Shows key codes
;
;
COMMENT~*********************************************************************
*  --++**> All code in this file is Copyright 1989 by David O'Riva <**++--  *
*****************************************************************************
*                                                                           *
* Written for the Microsoft Macro Assembler version 5.1                     *
*                                                                           *
*  MUST BE CONVERTED INTO A .COM FILE BEFORE RUNNING!!!                     *
*                                                                           *
*                                                                           *
* Short advertisement - use QEdit!  Get it from 143/37!                     *
*                                                                           *
****************************************************************************~
.XLIST
;
; Macros used by this program
;

?PLevel         =       0

PNPROC          MACRO   PNAME           ;;declare near public procedure
                IF2
                %OUT    Routine: &PNAME
                ENDIF
                PUBLIC  &PNAME
&PNAME          PROC    NEAR
?PLevel         =       ?PLevel+1       ;;next level of nesting
@@SAVE_NAME     &PNAME,%?PLevel
                ENDM

ENDPROC         MACRO
@@REC_NAME      %?PLevel
@@EP1           %@@TEMP
?PLevel         =       ?PLevel-1
                ENDM

@@SAVE_NAME     MACRO   PNAME,LVL
?PN&LVL         EQU     <&PNAME>
                ENDM

@@REC_NAME      MACRO   LVL
@@TEMP          EQU     
                ENDM

@@EP1           MACRO   PNAME
&PNAME          ENDP
                ENDM

PUSHM           MACRO   LST
IRP             REG,<&LST&>
                PUSH    REG
                ENDM
                ENDM

POPM            MACRO   LST
IRP             REG,<&LST&>
                POP     REG
                ENDM
                ENDM

@CHANGE_VECT    MACRO   INUM,GARB,NEW,GARB2,SAVEAREA
                MOV     AX,0
                MOV     ES,AX
                MOV     AX,ES:[INUM*4]
                MOV     DX,ES:[INUM*4+2]
                MOV     WPTR CS:[SAVEAREA],AX
                MOV     WPTR CS:[SAVEAREA+2],DX
                MOV     AX,OFFSET CS:NEW
                CLI
                MOV     ES:[INUM*4],AX
                MOV     ES:[INUM*4+2],CS
                STI
                ENDM

@RESTORE_VECT   MACRO   INUM,GARB,SAVEAREA
                MOV     AX,0
                MOV     ES,AX
                MOV     AX,WPTR CS:[SAVEAREA]
                MOV     DX,WPTR CS:[SAVEAREA+2]
                CLI
                MOV     ES:[INUM*4],AX
                MOV     ES:[INUM*4+2],DX
                STI
                ENDM

BPTR            EQU     
WPTR            EQU     
DPTR            EQU     
CR              EQU     <13>
LF              EQU     <10>
JR              EQU     

INT_CTRL        EQU     020H    ;Interrupt control port
EOI             EQU     020H    ;Reset interrupt controller command
KB_DATA         EQU     060H    ;Keyboard data port
KB_CTRL         EQU     061H    ;Keyboard control port
;
;****************************************************************************
;
BIOSDATA        SEGMENT AT 00040H

;----------------------------------------------------------------------------
;Keyboard Data Area
;----------------------------------------------------------------------------

                ORG     00017H
KB_FLAG         LABEL   BYTE

;----- Shift flag equates within KB_FLAG

        INS_STATE       EQU     80H     ;INSERT state is active
        CAPS_STATE      EQU     40H     ;CAPS LOCK state toggled
        NUM_STATE       EQU     20H     ;NUM LOCK state toggled
        SCROLL_STATE    EQU     10H     ;SCROLL LOCK state toggled
        ALT_SHIFT       EQU     08H     ;ALT key depressed
        CTRL_SHIFT      EQU     04H     ;CTRL key depressed
        LEFT_SHIFT      EQU     02H     ;left SHIFT key depressed
        RIGHT_SHIFT     EQU     01H     ;right SHIFT key depressed

                ORG     00018H
KB_FLAG_1       LABEL   BYTE

;----- Shift flag equates within KB_FLAG_1

        INS_SHIFT       EQU     80H     ;INSERT key depressed
        CAPS_SHIFT      EQU     40H     ;CAPS LOCK key depressed
        NUM_SHIFT       EQU     20H     ;NUM LOCK key depressed
        SCROLL_SHIFT    EQU     10H     ;SCROLL LOCK key depressed
        HOLD_STATE      EQU     08H     ;suspend key has been toggled

                ORG     00019H
ALT_INPUT       LABEL   BYTE            ;storage for alternate keypad entry

                ORG     0001AH
BUFFER_HEAD     LABEL   WORD            ;pointer to head of keyboard buffer

                ORG     0001CH
BUFFER_TAIL     LABEL   WORD            ;pointer to tail of keyboard buffer

                ORG     0001EH
KB_BUFFER       LABEL   WORD            ;keyboard buffer

                ORG     0003EH
KB_BUFFER_END   LABEL   WORD

;----- HEAD = TAIL indicates that the buffer is empty

        NUM_KEY         EQU     69      ;scan code for NUM LOCK
        SCROLL_KEY      EQU     70      ;sc for SCROLL LOCK
        ALT_KEY         EQU     56      ;sc for ALT key
        CTL_KEY         EQU     29      ;sc for CTRL key
        CAPS_KEY        EQU     58
        LEFT_KEY        EQU     42
        RIGHT_KEY       EQU     54
        INS_KEY         EQU     82
        DEL_KEY         EQU     83

BIOSDATA        ENDS


.LIST
.SALL
;
;****************************************************************************
;
CODE            SEGMENT PARA PUBLIC 'CODE'
                ASSUME  CS:CODE,DS:CODE,ES:CODE,SS:CODE

MAIN            PROC    FAR
                ORG     100H

ENTRY:          JMP     INSTALL

;============================================================================
;
; MY LOCAL DATA
;
;
;
OLD9            DD      ?       ;old INT 9 vector
;
;
LAST_KEY        DB      ?       ;make code from key trap
LAST_SHIFT      DB      ?       ;shift state on trap
KEYPRESSED      DB      ?       ;TRAP flag - non-zero = key was trapped
LINECOUNT       DB      ?       ;current count of lines on screen
SHIFTOVL        DB      'RLCA'  ;

NOTICE          LABEL   BYTE
DB CR,LF
DB 'SHOWKEY  v1.0  12-01-1988',CR,LF
DB 'COPYRIGHT 1988 ORIVATION',CR,LF
DB CR,LF
DB 'SHOWKEY shows the incoming scan codes from the keyboard hardware',CR,LF
DB '    and from the BIOS, and the shifts in effect at the press.',CR,LF
DB '    Type a "Q" to quit.',CR,LF

LINE0           DB      '+INCOMING CODES--+------+------+------+',CR,LF
                DB      '| ASCII | SHIFTS | KEYB | BIOS | EXTD |',CR,LF
                DB      '| CHAR  |  RLCA  | CODE | CODE | CODE |',CR,LF
                DB      '+-------+--------+------+------+------+',CR,LF,'$'

ILINE           DB      '|   '
ACHAR           DB      ' '
                DB      '   |  '
SHIFTS          DB      'RLCA'
                DB      '  |  '
KBC             DB      '00'
                DB      '  |  '
BIOSC           DB      '00'
                DB      '  |  '
EXTC            DB      '00'
                DB      '  |',CR,LF,'$'
;
;
;============================================================================


                PAGE
;****************************************************************************
; START - main program loop
;
;
;     ENTRY:    from command line
;
;      EXIT:    ???
;
; DESTROYED:    ALL
;
;----------------------------------------------------------------------------
PNPROC          START

                PUSHM   
                POPM    
;----------------------------------------------------------------------------
; print copyright notice
;----------------------------------------------------------------------------
                MOV     AH,9
                MOV     DX,OFFSET NOTICE
                INT     021H
                MOV     LINECOUNT,20
;----------------------------------------------------------------------------
;
;
; MAIN LOOP
;
;
;----------------------------------------------------------------------------
NEXT_CHAR_IN:   DEC     LINECOUNT
                JNZ     S_1
;
; reprint column headers if scrolled off screen
;
                MOV     DX,OFFSET LINE0
                MOV     AH,9
                INT     021H
                MOV     LINECOUNT,20
;----------------------------------------------------------------------------
; wait until our trap finds something
;----------------------------------------------------------------------------
S_1:            CMP     CS:KEYPRESSED,0
                JZ      S_1
;----------------------------------------------------------------------------
; reset trap and get 'make' code of key pressed
;----------------------------------------------------------------------------
                MOV     CS:KEYPRESSED,0
                MOV     AL,LAST_KEY
                MOV     SI,OFFSET KBC
                CALL    REGISTERTOTEXT
;----------------------------------------------------------------------------
; did BIOS pick up on the key?
;----------------------------------------------------------------------------
                MOV     AH,1
                INT     016H
S_2:            JNZ     S_3
;----------------------------------------------------------------------------
; if BIOS didn't get it, print dashes instead
;----------------------------------------------------------------------------
                MOV     WPTR BIOSC,('-'*256+'-')
                MOV     WPTR EXTC,('-'*256+'-')
                MOV     ACHAR,' '
                JR      S_6
;----------------------------------------------------------------------------
; print the key BIOS found
;----------------------------------------------------------------------------
S_3:            MOV     AH,0
                INT     016H
                PUSH    AX
                MOV     ACHAR,AL
;
; since we're using cooked console output, only print chars > 32
;
                CMP     AL,' '
                JAE     S_5

                MOV     ACHAR,' '
;
; get ASCII code of character
;
S_5:            MOV     SI,OFFSET BIOSC
                CALL    REGISTERTOTEXT
;
; and get extended (scan) code from BIOS
;
                MOV     SI,OFFSET EXTC
                POP     AX
                MOV     AL,AH
                CALL    REGISTERTOTEXT
;----------------------------------------------------------------------------
; read shift states in effect at the time of the press
;----------------------------------------------------------------------------
S_6:            MOV     AX,WPTR SHIFTOVL        ;* restore shift characters to
                MOV     WPTR SHIFTS,AX          ;|   output string
                MOV     AX,WPTR SHIFTOVL+2      ;|
                MOV     WPTR SHIFTS+2,AX        ;*
                MOV     SI,OFFSET SHIFTS        ;SI -> shift info to display
                MOV     AL,LAST_SHIFT           ;AL = shift codes in BIOSDATA
                MOV     CX,4                    ;CX = # of shifts to check

S_7:            SHR     AL,1                    ;shift bit -> carry flag
                JC      S_8                     ;if set, bypass this one
                MOV     BPTR [SI],' '           ;clear this shift character
S_8:            INC     SI                      ;SI -> next shift character
                LOOP    S_7                     ;check it
;----------------------------------------------------------------------------
; print a line of information about the keypress
;----------------------------------------------------------------------------
                MOV     AH,9
                MOV     DX,OFFSET ILINE
                INT     021H
;----------------------------------------------------------------------------
; if this character was a 'Q', then leave now
;----------------------------------------------------------------------------
                MOV     AL,ACHAR
                CMP     AL,'Q'
                JZ      S_OUT
;----------------------------------------------------------------------------
; more characters in BIOS buffer?
;----------------------------------------------------------------------------
                MOV     AH,1
                INT     016H
                JNZ     S_2
;----------------------------------------------------------------------------
; do next key
;----------------------------------------------------------------------------
                JMP     NEXT_CHAR_IN

;----------------------------------------------------------------------------
; leave
;----------------------------------------------------------------------------
S_OUT:          JMP     UNLOAD

ENDPROC

         
;****************************************************************************
; REGISTERTOTEXT - Converts AL into ASCII hex digits in CS:[SI]
;
;
;     ENTRY:    AL = register to translate
;               SI = place to put translated digits
;
;      EXIT:    AX = hex digits
;
; DESTROYED:    AX
;
;----------------------------------------------------------------------------
ASSUME ds:NOTHING,es:NOTHING
PNPROC          REGISTERTOTEXT
;----------------------------------------------------------------------------
; split AL into two nibbles
;----------------------------------------------------------------------------
                MOV     AH,AL
                SHR     AH,1
                SHR     AH,1
                SHR     AH,1
                SHR     AH,1
                AND     AL,0FH
;----------------------------------------------------------------------------
; convert AL into a hex digit
;----------------------------------------------------------------------------
                ADD     AL,'0'                  ;AL = actual digit
                CMP     AL,'9'
                JBE     R_1
                ADD     AL,'A'-'0'-10
;----------------------------------------------------------------------------
; convert AH into a hex digit
;----------------------------------------------------------------------------
R_1:            ADD     AH,'0'                  ;AH = actual digit
                CMP     AH,'9'
                JBE     R_2
                ADD     AH,'A'-'0'-10
;----------------------------------------------------------------------------
; store hex number in [SI]
;----------------------------------------------------------------------------
R_2:            MOV     CS:[SI],AH
                MOV     CS:[SI+1],AL
                RET
ENDPROC


                PAGE
;****************************************************************************
; TRAPPER9 - Intercepts the incoming keyboard scan code
;
;       This routine intercepts the keyboard hardware interrupt, looking
; for a valid "make" code.  If such a code is found, it is stored in local
; data along with the current shift state, and a flag is set indicating that
; a keypress was trapped.
;
;     ENTRY:    from IRQ 1, machine state is ???
;
;      EXIT:    continues KB interrupt chain
;
; DESTROYED:    none
;
;----------------------------------------------------------------------------
ASSUME ds:BIOSDATA,es:NOTHING
PNPROC          TRAPPER9

                STI                     ;since the keyboard interrupt mask
                                        ;is never cleared within this routine,
                                        ;there is no chance of accidental
                                        ;re-entry with interrupts enabled
                PUSHM         ;save everthing I use

                MOV     AX,SEG BIOSDATA ;DS-> BIOS's data seg
                MOV     DS,AX

                IN      AL,KB_DATA      ;Poll keyboard controller
                TEST    AL,080H         ;See if we got a 'make' code
                JNZ     T_ChainOn       ;If it's a 'break' code, ignore it...
;----------------------------------------------------------------------------
; ignore the four shift keys (CTRL, ATL, L-SHIFT, R-SHIFT)
;----------------------------------------------------------------------------
                CMP     AL,038H
                JZ      T_ChainOn
                CMP     AL,02AH
                JZ      T_ChainOn
                CMP     AL,01DH
                JZ      T_ChainOn
                CMP     AL,036H
                JZ      T_ChainOn
;----------------------------------------------------------------------------
; save info about this key
;----------------------------------------------------------------------------
                MOV     CS:LAST_KEY,AL  ;save key make code
                MOV     AL,KB_FLAG
                MOV     CS:LAST_SHIFT,AL;save current shift state
                MOV     CS:KEYPRESSED,1 ;set 'TRAPPED' flag

;----------------------------------------------------------------------------
; Continue down the KB handler chain...
;----------------------------------------------------------------------------
T_chainon:      POPM    
                JMP     DWORD PTR CS:OLD9
ENDPROC

                PAGE
;****************************************************************************
; UNLOAD - Unhooks all vectors and exits
;
;
;     ENTRY:    nothing
;
;      EXIT:    never exits.
;
; DESTROYED:    this program.
;
;----------------------------------------------------------------------------
ASSUME ds:CODE,es:CODE
PNPROC          UNLOAD

                @RESTORE_VECT 9 FROM OLD9       ;Restore keyboard vector
                MOV     AX,04C00H               ;Exit w/ERRORLEVEL 0
                INT     021H
ENDPROC


                PAGE
;****************************************************************************
; INSTALL - Installs traps, then runs the program.
;
;
;     ENTRY:    called on entry to the program
;
;      EXIT:    starts running main code
;
; DESTROYED:    assume ALL but DS
;
;----------------------------------------------------------------------------
ASSUME ds:CODE,es:CODE
PNPROC          INSTALL
;----------------------------------------------------------------------------
; install our keyboard hardware interrupt trap
;----------------------------------------------------------------------------
                @CHANGE_VECT 9 TO TRAPPER9 SAVEIN OLD9
;----------------------------------------------------------------------------
; continue program execution
;----------------------------------------------------------------------------
                JMP     START
ENDPROC


MAIN            ENDP
;
;****************************************************************************
;
CODE            ENDS
                END     ENTRY`



                         Book Reviews - February


With the wide assortment of books available for the IBM PC series and the
greatly differing quality some sort of review is desirable before
entering the bookstore. It is all too likely that you will come out
poorer by $100.00 or more. It is also important to purchase a book that
matches your level of experience.

Novice:

This is the most important of the levels. The basic information must be
complete, practical and be presented in a manner that informs without
confusing. The books that accomplish this are few indeed.


8088 Assembler Language Programming: The IBM PC
        written by David C. Willen & Jeffery I. Krantz
        published by Howard W. Sams & Co., Inc.

This book is a well-written introduction to the 8088 instruction set and
some of the hardware on a standard PC.  Has a complete explanation of
hexadecimal & binary numbering systems, an explanation of what assembly
language is and what it's good for.  Has chapters on keyboard, joystick,
monitor text modes, sound, interrupts, a bit about file handling and
more.  Includes programming examples.  Slightly outdated, uses DOS 1
functions and assumes MASM v1.0, but worth the price.


IBM PC-DOS Handbook
        written by Richard Allen King
        published by Sybex

This is a complementary book to the one above. They really contain different
material and together make a good starting point. This volume deals with the
interface to DOS versions 1 and 2.  Designed so that you can focus on
one thing you want to do, and look up everything DOS will do for you
towards that.  No programming examples.




Advanced:

These are books that assume a reasonable knowledge of assembly language and
delve deeply into the topics they cover.


Writing MSDOS device drivers
        written by Robert S. Lai
        published by The Waite Group (Addison-Wesley Publishing Company)

Quite possibly the definitive book on device drivers.  Assumes that you
are comfortable with assembly language.  Explains device drivers
completely, with lots(!!) of examples.  The most in-depth and complete
reference on the subject I've seen.
Includes a Console, Printer, Clock, and RAM Disk driver.


Programmer's Guide to PC & PS/2 Video Systems
        written by Richard Wilton
        published by the Microsoft Press

The best book I've seen for video.  Assumes complete knowledge of
assembly language and the ability to interpret hardware terms.
Unfortunately, the examples are written such that they interface with C,
but that could be easily changed.  Has complete information on MDA, HGC,
CGA, EGA, VGA, and MCGA adapters.  Includes line, arc, area-fill, and
adapter identification routines to name a few, along with complete port
programming information.  A must for graphics programmers.


DOS Programmer's reference
        written by Terry R. Dettmann
        published by QUE Corporation

The front of this book isn't that impressive (contains basic info about
DOS, BIOS, screen handling, memory etc.) but the last 400 pages are a
VERY impressive reference to all the BIOS interrupts, DOS interrupts
(including more undocumented functions than I've seen anywhere else),
Microsoft Mouse interrupt functions, which aren't documented in the
mouse package anymore, and the EMS interrupt functions (version 3.2).
If you need a good all-in-one reference, this is it.



NOTE:   I am positive that I overlooked a number of extremely good books
here.  We need you (the readers) to write reviews of books that deal
with assembly language and/or hardware for IBM PC's or any other system.
Since our main work is done on PClones and we don't really have access
to any other sort of system, we need reviews of books for 680x0, 6502,
and whatever else you're using.  Send all reviews in ASCII text form to
FidoNet node 143/37.  Thanx. - Dave



              GUIDE LINES FOR CONTRIBUTORS AND 'ADVERTISERS'


Name and address must be included with all articles and files

Executable file size and percent of assembly code (when available) should
be included when a program is mentioned and is required from an author or
publisher.

Any article of interest to Assembly language programmers will be considered
for inclusion. Quality of writing will not be a factor, but I reserve the 
right to try and correct spelling errors and minor mistakes in grammar. 
Non-exclusive copyright must be given. No monetary compensation will be made.

Outlines of projects that might be undertaken jointly are welcome. For 
example:
One person who is capable with hardware needs support from a user friendly
programmer and a math whiz.

Advertisements as such are not acceptable. Authors and publishers wishing to
contribute reviews of their own products will be considered and included as
space and time permit. These must include executable file size, percent of
assembly code and time comparisons.

Your editor would like information on math libraries, and reviews of such.

Articles must be submitted in pclone readable format or sent E-mail.
         Address: Patrick O'Riva
                  2726 Hostetter Rd
                  San Jose, CA 95132

Money: Your editor has none. Therefore no compensation can be made for 
articles included. Subscription fees obviously don't exist. Publication costs 
I expect to be nil (NUL). Small contributions will be accepted to support the 
BBS where back issues are available as well as files and programs mentioned in 


articles(if PD or Shareware ONLY).

;;;;;;;;;;;;;;

THE ASSEMBLY LANGUAGE "MAGAZINE"                  VOL 1 NUMBER 2
                                                  March 1989

















  ##     ####    ####   ####### ##   ## ######  ####    ##  ##
 ####   ##  ##  ##  ##   ##   # ### ###  ##  ##  ##     ##  ##
##  ##  ###     ###      ## #   #######  ##  ##  ##     ##  ##
##  ##   ###     ###     ####   #######  #####   ##      ####
######     ###     ###   ## #   ## # ##  ##  ##  ##   #   ##
##  ##  ##  ##  ##  ##   ##   # ##   ##  ##  ##  ##  ##   ##
##  ##   ####    ####   ####### ##   ## ######  #######  ####

        ####      ##    ##   ##   ####  ##  ##    ##      ####  #######
         ##      ####   ###  ##  ##  ## ##  ##   ####    ##  ##  ##   #
         ##     ##  ##  #### ## ##      ##  ##  ##  ##  ##       ## #
         ##     ##  ##  ## #### ##      ##  ##  ##  ##  ##       ####
         ##   # ######  ##  ### ##  ### ##  ##  ######  ##  ###  ## #
         ##  ## ##  ##  ##   ##  ##  ## ##  ##  ##  ##   ##  ##  ##   #
        ####### ##  ##  ##   ##   ##### ######  ##  ##    ##### #######















Written by and for assembly language programmers.






          
          
          
          
                            March     1989    Contents
          
          Policy...................................................  3
          
          Editorial................................................  4
          
          Beginners Corner.........................................  5
          
          What is SDN?.............................................  7
          
          FASTPRINT................................................  8
                   by Dennis Yelle
          The EXEC Function........................................ 11
                   by Patrick O'Riva
          TSR's.................................................... 13
                   by David O'Riva
          Book Reviews............................................. 17
          
          Program Spotlight........................................ 18
          
          
          Source listings in order of appearance
          
          
          
          
               It has been suggested that the source listings be placed
          at the end of the "Magazine" rather than following the
          associated article. If you prefer it one way or the other
          please advise the editor.
          
          Address of The Assembly Language "Magazine"
                    AsmLang and CFS  FidoNet 143/37 408-259-2223
                    Patrick O'Riva
                    2726 Hostetter Rd.
                    San Jose, CA 95132
          
















                                        2





          
          
                   GUIDE LINES FOR CONTRIBUTORS AND 'ADVERTISERS'
          
          
               Name and address must be included with all articles and
          files.  Executable file size and percent of assembly code
          (when available) should be included when a program is
          mentioned and is required from an author or publisher.
          
               Any article of interest to Assembly language programmers
          will be considered for inclusion.  Quality of writing will not
          be a factor, but I reserve the right to try and correct
          spelling errors and minor mistakes in grammar.  Non-exclusive
          copyright must be given. No monetary compensation will be
          made.
          
               Outlines of projects that might be undertaken jointly are
          welcome.  For example: One person who is capable with hardware
          needs support from a user friendly programmer and a math whiz.
          
               Advertisements as such are not acceptable.  Authors and
          publishers wishing to contribute reviews of their own products
          will be considered and included as space and time permit.
          These must include executable file size, percent of assembly
          code and time comparisons.
          
               Your editor would like information on math libraries, and
          reviews of such.
          
               Articles must be submitted in pclone readable format or
          sent E-mail.
          
          
               Money: Your editor has none.  Therefore no compensation
          can be made for articles included.  Subscription fees
          obviously don't exist.  Publication costs I expect to be nil
          (NUL). Small contributions will be accepted to support the BBS
          where back issues are available as well as files and programs
          mentioned in articles(if PD or Shareware ONLY).
          
               Shareware-- Many of the programs mentioned in the
          "Magazine" are Shareware.  Most of the readers are prospective
          authors of programs that can be successfully marketed as
          Shareware.  If you make significant use of these programs the
          author is entitled to his registration fee or donation.
          Please help Shareware to continue to be a viable marketing
          method for all of us by urging everyone to register and by
          helping to distribute quality programs.








                                        3





          
                                    Editorial
          
               This is the second monthly edition of the Assembly
          Language Magazine.  I have been disappointed in the response
          to the first issue both in the number of comments I have
          received and in the lack of articles submitted for inclusion
          in this issue.  I would like to give a special thank you to
          Richard Hendricks for his letter of suggestions and comments,
          most of which I hope to address in this issue. He felt that a
          less full look to the pages would improve the readability and
          appearance.
          
               My original idea was to fill the page as much as possible
          to reduce the amount of print out.  Many of his other comments
          reflect my lack of experience as an editor, and I will try to
          improve.
          
               Without some articles being sent in this will be near the
          last issue. The time is not available for your editors to
          write the entire magazine every month, and even if it were,
          the quality would suffer from lack of variety. Please send
          those submissions.
          
               Please excuse the late publication this month.
          
                                      ERRATA
          
               The name of the Author of the A86 Assembler was
          misspelled.  The correct spelling is: Eric Isaacson
          
               In the article about fast memory moves I repeatedly
          referred to the 8259 as the DMA processor.  The 8259 is the
          interrupt controller and has nothing to do with DMA transfers.























                                        4





          
                                Beginners Corner.
          
               Obviously the first requirement for learning any assembly
          language is to have a list of the instructions.  This may
          sound easy and it is something that most novice level books
          claim to have, but it is one of the most difficult things to
          find.
          
               Every source I have found is very incomplete and/or
          unclear.  The exact use of each command and the hundreds of
          variations on each forces even scarred veterans to look back
          at a reference now and again.
          
               At least one of your references must contain the clocks
          data for each instruction.  For the 80XXX series of processors
          this is a very confusing table of adds for all occasions. The
          basic time for the instruction is given plus the number of
          accesses plus EA calculation.  It is different for a
          conditional jump taken and when it is not.  To make matters
          even worse we are dealing with not one processor, but with at
          least 5: 8088, 80286, 80386, V20, V30.  Each of these works
          differently and thus each has its own timing.  Because it is
          the worst case and because there are so many installed it is
          always best to use the timing for the 8088 unless you are
          writing for a particular application or system.
          
               A first glance at the EA calculation table will be very
          enlightening to those who have used a high level language.
          Most of the variables passed and most all of the structures
          addressed are done with pointers and offsets to pointers.
          These are VERY costly time wise.  Even pushes and pops take
          far longer than one would think.  A memory access (fetching
          the value of a variable) especially using the AX register pair
          is faster than a push and pop.  Be familiar with your
          instructions and how long they take.  Only use half of the
          register pair if that is all you need because it saves an
          additional fetch, cutting the time almost in half.
          
               A clear verbal description of each instructions including
          its peculiarities is essential. This is true for all, but the
          more complex instructions such as rep movsb make it mandatory.
          
               Each instruction should list the flags it can affect.
          These are not always what you want or need.  For example: the
          INC instruction does not affect the carry flag.  As silly as
          it may sound you have to use an instruction that affects the
          flag you want to test for.
          
               The Rotate and Shift group of instructions should be
          accompanied with diagrams showing their operation. A glance at
          the diagrams will show exactly which one to use where it could
          take reading pages to do the same thing.
          



                                        5





               One final note of caution that seems to fit in here --
          unless you are doing signed arithmetic operations avoid the
          use of the JG and JL type instructions.  They take the sign
          bit into account and can cause very hard to trace bugs.  Use
          the JA and JB instructions instead.
          
               Your next most important reference is a description of
          the BIOS calls.  Most of these are very straight forward and
          require little by way of explanation.
          
               Next comes a DOS reference. The critical ones of these
          are also quite simple to understand and use. Don't get
          involved with FCB's; the handle method of file access is the
          only way to go.
          
               For your BIOS and DOS references almost any will work,
          but your basic instruction description look long and hard. You
          will probably end up with several you use regularly.
          
               With all of your reference works stacked up around you,
          sitting at your computer, what next?  You need to choose an
          assembler.  There are at least 4 major packages available,
          each with its supporters and its weaknesses. The Microsoft
          MASM is complete and the de facto standard.  It is also large
          and slow. TASM from Borland is faster, and is mostly
          compatible, but tricky for beginners. Optasm I am not very
          familiar with, though it sounds pretty good. It is much faster
          than MASM, and is a full 2 pass assembler. If you are not
          concerned with compatibility A86 is fast, small and simple to
          use, and the D86 debugger is adequate.
          
               The text editor you use must produce a pure ASCII file.
          Whatever you enjoy is the one to use. Qedit from Semware can
          be configured to act like almost any other, and is fast and
          small.
          
                 Next month: Segmentation and Memory allocation.
          
                                Useful Shareware:
          1029ref                       DOS and Pc Tech Reference
          inter                         Complete interrupt listing
          @last200                      Pop up tables
          LW86                          Pop up instruction summary
          Qedit                         Text editor
          A86                           Assembler
          D86                           Symbolic Debugger











                                        6





          
                                   What is SDN?
          
               SDN stands for Shareware Distribution Network. It is a
          relatively new organization operating largely within FidoNet
          but in no way affiliated with it. SDN receives software direct
          from the author on disk, compresses it using the PAK facility
          from No Gate and distributes it to affiliated BBS's throughout
          the country, in a highly traceable manner.
          
               This distribution method is advantageous for both the
          author and  the user. It assures the author of quick and
          complete distribution nationwide, and it assure the user of
          complete and uncontaminated software.
          
               There is no charge to either the author or the user for
          this service, but the author must comply with the instructions
          for transmitting the software to the SDN home point.
          
               Complete information is available from your local SDN BBS
          or as a last resort you can get the informational files from
          AsmLang.



































                                        7





          
          
                    FASTPRINT: The fix for one of PRINT's bugs
                                 by Dennis Yelle
          
          
               Does your printer slow down when you run LIST or your
          favorite editor, word processor, debugger, or other program
          that spends most of its time just waiting for you to type at
          it?  Does this annoy you?  It annoyed me!  It annoyed me
          enough so that I did something about it.
          
          How to use it:
          --------------
               Just type FASTPRINT at the DOS prompt, either before or
          after you run PRINT.  Or put the FASTPRINT command in your
          AUTOEXEC.BAT file, that's what I do.  If you put FASTPRINT in
          your AUTOEXEC.BAT file, it should normally be placed AFTER any
          utility that increases the size of the keyboard type-ahead
          buffer.
          
          How it works, if you like grubby details:
          -----------------------------------------
               The PRINT command installs a TSR that prints files in the
          background.  This allows you to run other programs on your
          computer while the file(s) print.  The PRINT TSR "steals" some
          computer time from you, but usually not enough to bother you.
          The problem is that sometimes (usually) it doesn't steal
          enough to keep the printer running at anywhere near full
          speed.  Fortunately, there is a way to "give" the PRINT TSR
          more time.  And, it turns out that COMMAND.COM does just that
          when it is waiting for you to type a DOS command.  The problem
          is that most programs that you run don't do this.  And so the
          printer slows down.  ugh!  Now we get to the good part.
          FASTPRINT looks for some signs that indicate that the
          foreground program is waiting for something, like a keystroke,
          and tells PRINT to do some printing while we wait.
          
          How it works, only for those who like the REALLY grubby
          details:
          -------------------------------------------------------
          
               The way to "give" the PRINT TSR some computer time is to
          put 0080H in AX, and do an INT 2FH.  What FASTPRINT does, is
          link itself into interrupts 15H and 16H.  INT 16H is used to
          read the keyboard.  When a program tries to read a key that
          the human has not typed yet, FASTPRINT gives PRINT a bit of
          computer time, and then checks to see if the human has typed
          the key yet.  If not, then it gives PRINT some more time and
          checks the keyboard again...INT 15H function 90H is used on
          the AT only to tell other programs that we are waiting for
          something that may take some time.  So, if this happens, then
          FASTPRINT gives some time to PRINT.




                                        8





               To make FASTPRINT even more useful to those who like
          grubby details, I am including the A86 source code for the
          program.
          
          How to pay for it:
          ------------------
          1. If it is before March 30, 1989 then just:  Send a message
          to me reporting how well FASTPRINT worked for you, including:
          
          (A. the hardware you are running on;
          (B. the version of DOS you are using;
          (C. how well it works, that is, for example, how many seconds
          does it take to print a www byte xxx line file with a yyy
          printer with and without using FASTPRINT while inside program
          zzz; and
          (D. anything else you have discovered about it, including any
          incompatibility with other programs.
          
               You may send this message to my PO Box, or to me at any
          of these BBS'S:
                          AsmLang and CFS (Opus 1:143/37)  408-259-2223
                          HomeBase 408-988-4004
                          PDSE     408-745-0880
          
          2. Just send a check for about 1/4 of what you think it is
          worth to you to:
              Dennis Yelle
              P. O. Box 62276
              Sunnyvale, CA  94088
          
               If you want to donate, but don't know how much it is
          worth, then just send me $10.
          
          3. FOR PROGRAMMERS ONLY:  If you want to use any or all of the
          source code in the file FASTPRIN.8 in your own program(s), you
          may buy the right to do so for $25.
          
          Legal mumbo jumbo
          -----------------
               This document and the program files FASTPRIN.COM and
          FASTPRIN.8 are copyrighted by the author.  The copyright owner
          hereby licenses you to: use the software; make as many copies
          of it as you wish; give the copies to anyone; and to post this
          .ARC file on BBS'S, if the BBS is free.  There is no charge
          for any of the above.
               However, you are specifically prohibited from charging,
          or requesting donations, for any copies, however made; and
          from distributing this software and/or documentation with
          commercial products without prior permission.
               No copy of this software may be distributed or given away
          without this document; and this notice must not be removed.
          There is no warranty of any kind, and the copyright owner is
          not liable for damages of any kind.  By using this software,
          you agree to this.



                                        9





          
          --------------------------------------------------------------
               Editors note: This is the documentation for FASTPRINT and
          has been included in the magazine at the author's suggestion
          as it describes the operation, is written in assembly and
          includes the source.



















































                                        10





          
                                The EXEC Function
                                        by
                                  Patrick O'Riva
          
               The EXEC function is one of the most powerful features of
          DOS.  It allows shelling out of an application, and even going
          as far as invoking another command interpreter. It is also
          rather complex to use and there is no debugging help from DOS.
          
               The EXEC command comes in three basic flavors; Load and
          execute a file, Load and overlay, and the 3rd is an internal
          DOS function of load a file. Only the load and execute a file
          will be covered in detail this month.
          
               I freely admit I'm not an expert on the use of the EXEC
          function, but I have convinced it to work for me and done so
          recently enough I can remember most of the mistakes. If anyone
          reading this is better informed, I encourage them to write a
          supplementary article.
          
               DOS requires that you supply three separate pieces of
          information. The program  fully qualified as to
          drive, path, filename and extension. My experience is that it
          will not make a path search, but this might be inaccurate and
          caused by a slight error in syntax. The second item is the
          command line arguments in DOS format, where the first byte
          specifies the length of the argument including the length
          byte.  The third item is an environment block. For this one
          you are allowed to default to current block as passed to the
          program you are EXEC'ing out of. To execute a batch file or
          use the built-in DOS commands you must EXEC command.com itself
          and pass the program name in the arguments.
          
               For "load and execute" a program the syntax is as
          follows:
          
               AH=4Bh    EXEC function number within INT 21h
               AL=0      specify "load and execute"
               DX        points to program name,
                              i.e. 'C:\MYSTUFF\RUNME.EXE'
               ES:BX     points to the "EXEC control block", defined
                         as follows:
                           WORD   segment of environment block to pass
                               if 0 defaults to parent block.
                               environment is assumed to be at offset 0
                               within this segment
                           DWORD  pointer to command tail
                           DWORD  pointer to 1st FCB
                           DWORD  pointer to 2nd FCB
          
               "COMMAND TAIL" is defined as that portion of a command
          line following the program name, preceded by a one byte count




                                        11





          of the length of the tail plus 1 for the terminating CR (0Dh),
          i.e.      DB   12,'/h /Ox1.obj',0Dh
          
               The first job most any program should do is return to DOS
          any portion of memory that is not required. Without this
          operation there would be no place for DOS to load the new
          program. It is also best to do this to inform your program how
          much memory is available to it to use for data storage and
          other general uses. If FFFF paragraphs are requested from DOS
          naturally a fail will be returned, but more importantly the
          amount available will also be returned. After determining that
          there is sufficient to at least attempt the EXEC the program
          can continue.
          
               Let's use the terms parent and child for the two
          programs.  Once the EXEC is called the parent has no further
          control over the operation of the child. All control must be
          exercised through the information passed in the parameter
          block.  You can tailor the environment block, specify the
          command tail, and point the 2 FCB's if the program uses them.
          If the program doesn't use them you can just point them to 5CH
          and 6CH of the parent's PSP(The segment address is supplied by
          DOS in ES and DS after the parent is loaded).
          
               I am including a short program that does nothing except
          EXEC according to your instructions.  With some playing around
          it should be a good introductory tool.  A sample program name
          and command tail are included, but these you will want to
          change.
          
               Some of the code in there is unnecessary, but may make it
          easier to customize or illustrates some point. With relatively
          small changes this could be included in another program to
          serve as an exec subroutine.  The source is compatible with
          both MASM and A86.






















                                        12





          
                                      TSR's
                         How to get user input, Part Two
                       (along with lotsa other neat stuff)
                                 by David O'Riva
                                         
               This article is a multi-part package, all rolled into one
          month, mainly because a good deal of it comes in one chunk:
          How to write a well-behaved TSR. For those of you who aren't
          quite sure what a TSR really is, a short definition follows.
          
               TSR, n, 1. Terminate and Stay Resident.   2. A program or
          routine that, after being loaded, carves a niche of memory for
          itself and holes up there, only showing itself when a certain
          circumstance occurs.  This is what is meant by"serially
          multitasking."  You press a "hotkey", and for some length of
          time the program you were working on is subjugated to the
          background, and the TSR gets to use the computer.
                         3. A real pain to write.
          
               TSR'S have numerous uses:  print spoolers, expanded
          keyboard buffers, text editors, directory manipulators,
          background disk formatters, display managers, background file
          transferors - anything you may want to do while you're in the
          middle of another application.
               TSR's usually have the following basic structure
          (depending on what they do):
          
                  jump to initialization
          
                  main body of resident code
          
                  keyboard interrupt interceptor
          
                  timer tick interceptor
          
                  DOS console interceptor
          
                  un-installation routine
          
                  initialization code
          
          
               An explanation of each of these follows:
          
          
                               Initialization Code
          
               The initialization code must check to see if the TSR is
          already resident in memory (aborting if so), hook all of the
          interrupt servers into their respective chains, perform any
          other tasks necessary to install the program, then deallocate
          all unused memory and exit to DOS with a TSR call.
          



                                        13





               To determine whether or not a copy of the TSR is already
          resident, you could assign an unused interrupt to it.  The
          example uses INT 69H, function ABCD hex.  If the example is
          already installed, it returns with DCBA hex in AX.
          
               This "residency check" interrupt could also handle
          functions for the TSR:  i.e. if the TSR was a print
          spooler,and there was no "hot key" code written for it (like
          the DOS PRINT command), then the program could call INT 69H
          with function AB00H to add a file to the print queue.
          
               To hook an interrupt into a chain, you must replace the
          appropriate vector with a pointer to your interrupt server,
          and your interrupt server must jump to or call the code that
          the vector used to point to.  Failure to do this caused many
          early TSR's to refuse to co-habit with other TSR's,
          occasionally making the machine bomb, etc...  Unless you have
          a very good reason, ALWAYS continue the interrupt chain.
          
               Two TSR exits are available:  The first is INT 27H,which
          has some limitations (only 64K of your program can remain
          resident, which shouldn't be too onerous), and which Microsoft
          does not recommend for anything except DOS 1.  The second is
          INT 21H function 31H, which allows up to a meg to remain
          resident (right) and allows you to send a return code back to
          the caller.
          
               The initialization code usually de-allocates itself upon
          exiting.
          
          
                          Keyboard Interrupt Interceptor
          
               This is only required for programs that wish to pop up
          when the hot key is pressed or wish to monitor the keyboard
          for some other reason.  Much of what they have to do was
          discussed last month, with two exceptions.
          
               The first is how to prevent a keystroke from reaching the
          BIOS code without leaving the keyboard locked up.  To do this,
          you have to tell the keyboard that you received the character,
          then reset the interrupt controller and exit (without chaining
          to the next interrupt.)  The keyboard is cleared by toggling
          bit 7 of port 61H on, then off.  The interrupt controller is
          cleared by sending an EOI(End Of Interrupt) code 20H to the
          8259 at port 20H (weird,huh?).  At that point you should do an
          IRET.
          
               The second is the necessity of monitoring the InDOS flag.
          Note that YOU ONLY HAVE TO DO THIS IF YOUR TSR USES DOS
          FUNCTIONS.  Also note that this flag is NOT documented by IBM
          OR Microsoft, and that it is not strictly "compatible."
          




                                        14





               The address of the InDOS flag can be acquired by a call
          to INT 21H function 34H.  The flag is non-zero if a DOS
          function is currently active.  You need this flag because DOS
          is not re-entrant.  That is, if you call DOS from your TSR,and
          DOS was active when the TSR gained control, the TSR will work
          fine, but when you return from it, the function in progress
          will have lost its entire stack and much of its data area.
          Nasty stuff.
          
               If the InDOS flag is set when the keyboard trap is
          activated, the keyboard trap should set a flag saying "I want
          to activate but I can't" and return.
          
          
                              Timer Tick Interceptor
          
               These are always fun.  18.2 times per second, you get
          control of the machine.  This is useful for print spoolers,
          resident screen clocks, and TSR'S that need to perform DOS
          functions.
          
               In the last case, the timer tick trap should check to see
          if the TSR wants to activate, and if so whether the InDOS flag
          is set.  If the InDOS flag is clear, then the TSR can be
          activated.
          
          
                             DOS Console Interceptor
          
               This interrupt (INT 28H) is called by DOS whenever a DOS
          console function is in progress.  This is useful to have
          because during a console input, the InDOS flag is set, but it
          is actually safe to use any DOS function ABOVE 0CH.
          
               This trap should check to see if the TSR wants to
          activate, and if so then activate it.
          
          
                               Main Body of the TSR
          
               The only requirement for this is that if you use more
          than two words (yes, this is an arbitrary measure that seems
          safe to me) of stack, you should use your internal stack
          instead of the one that you were called with.  This is because
          you have no idea how large the stack you're working on is, and
          no way of telling how far you can go before you start to
          overwrite data...
          
          
                           The Un-Installation routine
          
               This is a very nice thing to have.  The only problem is
          that it needs to use a DOS call to de-allocate its memory.




                                        15





          Unless, of course, you want to directly modify the memory
          control blocks... which could be very dangerous.
          
               The routine in the example TSR does check the memory
          control block immediately after it to make sure that there are
          no programs installed in memory after the TSR.  DOS gets upset
          when there are "holes" in memory.  At least, it's supposed to.
          The structure included for the MCB is complete as far as I
          know, but it is also *extremely* undocumented.  Microsoft
          calls it an "arena header" and tells programmers to keep their
          hands off of it.
               All vectors must be unhooked.
          
               The DOS calls to de-allocate the memory are necessary.
          
          
                           Neat tricks you can pull...
          
               The command line area in the PSP makes for a convenient
          40 word internal stack.  If you aren't using the FCBS, the FCB
          storage area can be commandeered as well.
          
               The environment segment's size can be checked (with a
          look at the MCB) and that can be used for stack, data or code
          as well.
          
          
          The Example TSR
          
               As far as actual use goes, the example TSR is a very
          simple beast.  When resident, press LSHIFT-RSHIFT-T (it'll
          beep).  Then press "Q" to return to normal processing, or
          press "N" to Nuke the TSR (remove it from memory).  If it
          cannot remove itself, it will beep three times.
          
               Well, that's about all there is to it.  With all these
          routines (or at least the ones you need) combined in one
          cohesive package, you have a full-fledged TSR skeleton. The
          example TSR includes most of these techniques.  Use and enjoy.
          Comments on this article, or expansions on the subject matter
          are greatly appreciated and will be published in later issues
          of the magazine.















                                        16





          
          
                          Book Reviews by Patrick O'Riva
          
          
          
          PROGRAMMER'S TECHNICAL REFERENCE FOR MSDOS AND THE IBM PC
               By Dave Williams P.O. box 181, Jacksonville, AR 72087
          
               This is a first glance review that I wanted to get into
          this month's issue.  It is a user supported book on disk.  I
          haven't had the time to read through it, but it appears to be
          one of the best available in any format.  In compressed form
          it is over 200k, and expands to over 500k.  It is very
          complete and includes some hard to find tables and version
          histories.  Requested $15 support includes 2 additional disks
          and updates.  Probably one of the best buys around.
          
               It is available on various BBS's (AsmLang included)
          though its 200k+ size makes for slow distribution.  The
          complete package direct from the author is probably best.
          
          
          IBM Technical Reference- Personal Computer XT
          
               This comes in the standard binder/box and is available
          from IBM corporation at a hefty $50. In addition to some
          information on port assignments and memory maps it contains
          two sets of information that I have found nowhere else.
          
               A complete listing of the ROM BIOS for the XT that is
          invaluable as both an example of programming each piece of
          hardware and clues as to how to optimize for a specific
          application.
          
               Complete schematics of the motherboard of the XT that can
          help to explain why something won't work if you are
          technically inclined.
          
               I have found it invaluable, but it is not for everyone.
               Similar publications are available for the other IBM
          products and for the PCDOS.
               For further information contact IBM at 1-800-426-7282














                                        17





          
          
                                Program Spotlight
                               Exceptional Programs
          
               This is really a nonexistent column this month as nothing
          new has come to my notice that meets the qualifications of
          high speed and small size.
          
               There is a nice piece of source code available under the
          name of CRC16 that calculates and verifies 16 bit CRC values.
          If this meets a need of yours keep a look out for it.
          
               Although I haven't tried it out yet, a program called the
          Brand X symbolic debugger has been highly recommended to me.
          Other comments would be welcomed.
          
               QFILE31G handles copying, deleting and moving files, as
          well as maintaining and listing ARC's and ZIP's. Nicely done,
          but too slow and too large to really fit here, and hangs up on
          some error conditions.
          
               WHIZ1 a file finding program certainly qualifies in speed
          as a multi disk search with wild card only takes a few
          seconds.  It is a bit larger than it might be, but at the
          least it is enhanced with assembly routines. It is a shareware
          offering and is widely available.






























                                        18



;Ed -This is the source code on FASTPRINT
        jmp     install ; This will be a .COM

db cr, '   ', cr, lf     ; On most displays, if this file is TYPEed,
               ; these 3 spaces will erase
               ; the 3 characters in the JMP instruction above.
message0:
     db   'FASTPRIN 0.0 Copyright 1989 by Dennis Yelle,'
     db   ' PO Box 62276, Sunnyvale CA 94088'
     db   cr, lf
message0_len = $ - message0
     db   'Last change:  Mar 4, 1989', cr, lf

db 26     ; This 26 is a control-Z, the DOS EOF character.
     ; I put it here so that if someone TYPEs this .COM file,
     ; only the characters before the 26 will be printed on the screen.

id_size = $ - 0100

;    To assemble this program, put the source in a file called
;    FASTPRIN.8 and then type
;    A86 FASTPRIN.8
;    This will produce a file called FASTPRIN.COM directly,
;    in about 2 seconds!  No need to run a linker!
;    The program A86.COM is available from many BBSs in an .ARC file
;    that starts with A86.
;    In particular, A86.COM is available from the "AsmLang and CFS" BBS
;    (Opus 1:143/37) 408-259-2223 in the file A86V319A.ZIP.
;    Or HomeBase 408-988-4004 in the file A86V309A.ARC.
;    Or PDSE     408-745-0880 in the file A86V314A.ARC.
;
;    FASTPRIN installs a TSR which speeds up the printing done by the
;    DOS PRINT command by calling INT 02FH with AX = 0080H whenever the
;    system is idle.  We know the system is idle whenever:
;
;    1. INT 016 is called with AH = 0 and there are no characters in
;       the keyboard buffer.  or
;    2. INT 015 is called with AH = 090.  This will only happen on an AT.
;
;    Termination codes:
;         0 - Successfully installed.
;         1 - Unable to determine if already installed, installed anyway.
;         2 - Already installed.
;
;    If this program has been helpful to you, then please send a
;    small gift to the author, Dennis Yelle, PO Box 62276,
;    Sunnyvale, CA  94088.  A gift of $10 is suggested.

cr = 0d
lf = 0a

     even
old_int_15 dw 2 dup (?)
old_int_16 dw 2 dup (?)

get_vect macro
     push es
#rx1l
     mov  ax, 03500 + 0#x


     int  021
     mov  old_int_#x, bx
     mov  old_int_#x[2], es
#er
     pop  es
#em

set_vect macro
#rx1l
     mov  dx, offset new_int_#x
     mov  ax, 02500 + 0#x
     int  021
#er
#em

new_int_16:
     pushf
     sti
     test ah,ah
     jz   wait_16
     popf
     jmp  cs: d old_int_16

wait_16_loop:
     mov  ax, 0080
     int  02f       ; Do some printing.
wait_16:
     mov  ah, 1
     int  016       ; Are any chars ready?
     jz   wait_16_loop   ; Jump if not.
     mov  ah, 0
     popf
     jmp  cs: d old_int_16

new_int_15:
     pushf
     sti
     cmp  ah, 090
     je   idle
     popf
     jmp  cs: d old_int_15

idle:
     push ax
     mov  ax, 0080
     int  02f       ; Do some printing.
     pop  ax
     popf
     jmp  cs:d old_int_15

end_of_resident:
;---------------------------------------------------------

install:
     mov  ah, 040
     mov  bx, 1          ; Write to stdout
     mov  dx, message0
     mov  cx, message0_len
     int  021
     mov  ah, 052


     int  021
     mov  ax, es:[bx-2]
     mov  dx, ds
     dec  dx
     cld
find:
     cmp  ax, dx
     je   install_it
     ja   mem_bad
     mov  es, ax
     mov  si, 0100
     mov  di, 0110
     mov  cx, id_size/2
     repe cmpsw
     je   already_installed
     stc
     adc  ax, es:[3]
     jnc  find
mem_bad:  
     mov  w installed_msg, mem_bad_msg
     inc  b term_code
install_it:
     get_vect 15, 16
     set_vect 15, 16

     mov  ah, 049
     mov  es, [02c]
     int  021       ; Free the ENV segment.

     mov  dx, installed_msg
     mov  ah, 9
     int  021       ; Print the INSTALLED message.

     mov  ah, 031
     mov  al, term_code
     mov  dx, (end_of_resident+15)/16
     int  021       ; Terminate and stay resident.
;-------------------------------------------------------------

already_installed:
     mov  dx, ai_msg
     mov  ah, 9
     int  021       ; Print the message.
     mov  ax, 04c02
     int  021

installed: db 'FASTPRIN is now installed.', cr, lf, '$'

mem_bad_msg:
db 'FASTPRIN was unable to determine if it was previously installed, or not,'
db cr, lf,
db 'so it installed itself anyway.', cr, lf, '$'

ai_msg: db 'FASTPRIN was already installed.', cr, lf, '$'

installed_msg dw installed
term_code     db 0


;THIS IS THE SOURCE CODE FOR THE EXEC FUNCTION ARTICLE
;
;THIS PROGRAM WITH FEW IF ANY SYNTAX CHANGES SHOULD BE COMPATIBLE WITH BOTH A86
;AND MASM.
;IT IS NOT DESIGNED TO BE A STAND ALONE PROGRAM OR EVEN USER FRIENDLY BUT A
;BARE SHELL WITH WHICH TO PLAY AROUND WITH IN LEARNING TO USE THE DOS EXEC
;FUNCTION
;THE PROGRAM NAME SHOULD BE ENTERED BETWEEN THE QUOTE MARKS AT THE VARIABLE
;-PROGRAM- AND ANY OTHER COMMAND LINE ARGUMENTS SHOULD BE ENTERED BETWEEN THE
;QUOTE MARKS AT THE VARIABLE -COMMAND- BEFORE ASSEMBLY. MANY IMPROVEMENTS ARE
;OBVIOUS, SUCH AS BEING ABLE TO ENTER THE NAMES AND ARGUMENTS FROM THE CONSOLE
;BUT THESE ARE LEFT TO EXPERIMENTER.
;THE ONE SOPHISTICATION IF YOU COULD CALL IT THAT IS THAT THE ERROR LEVEL OF
;THE EXEC'D PROGRAM IS FETCHED, BUT NOTHING IS DONE WITH IT.
CODE SEGMENT 'CODE'
ASSUME CS:CODE,DS:CODE,ES:CODE,SS:CODE
org     0
PROG_ORG        LABEL   BYTE
org     0100
ENTRY:          JMP     START


                db      32 DUP ('STACK   ')     ;THIS SETS ASIDE 256 BYTES-
                                                ;REQUIRED DOS STACK
STAK            LABEL   BYTE                    ;THIS MARKS TOP OF STACK

THIS_SEG        DW      0               ;STORAGE FOR ADDRESS OF THIS SEGMENT

CTL_LEN         DW      0               ;THIS IS THE START OF THE *****
PROGRAM         DB      'c:\dos\list.com',0           ;ASCIIZ STRING OF PROGRAM TO
EXEC

CMDL            LABEL   BYTE            ;BEG ADDRESS OF COMMAND TAIL
CMDLEN          DB      0               ;OFFSET CR - OFFSET COMMAND
COMMAND         DB      'exec.asm'             ;THE COMMAND TAIL ITSELF
CR              DB      0DH             ;TERMINATING CARRIAGE RETURN

PARMS           LABEL   BYTE            ;ADDRESS OF PARAMETER TABLE
 ENV            DW      0               ;POINTER TO ENVIRONMENT BLOCK
                                        ;0 DEFAULTS TO PARENT
 CMDLNLOW       DW      0               ;OFFSET OF COMMAND TAIL
 CMDLNHI        DW      0               ;SEGMENT OF COMMAND TAIL
 FCB11          DW      0               ;OFFSET  OF FCB1
 FCB12          DW      0               ;SEGMENT OF FCB1
 FCB21          DW      0               ;OFFSETT OF FCB2
 FCB22          DW      0               ;SEGMENT OF FCB2
MS1             DB      'DEALLOCATION ERROR',0DH,'$' ;MESSAGE #1
MS2             DB      'EXEC ERROR',0DH,'$'         ;MESSAGE #2
START:
                CLI                     ;TURN OFF INTERRUPTS WHILE SWITCHING
                                        ;STACK FRAMES
                MOV     SP,OFFSET STAK  ;POINT STACK WHERE WE WANT IT
                STI                     ;INTS OK NOW
                MOV     AX,DS           ;BEING A COM PROGRAM DS CONTAINS THIS
                                        ;SEGMENT
                MOV     THIS_SEG,AX     ;PUT IT WHERE WE CAN GET IT EASILY
RESIZE:
                MOV     BX,(OFFSET PROG_END - OFFSET PROG_ORG)  ;FIND OUT
                                        ;HOW BIG THE PROGRAM IS
                MOV     CL,4            ;TURN THIS VALUE INTO PARAGRAPHS


                SHR     BX,CL
                                        ;
                INC     BX              ;NEEDS 1 MORE TO CATCH OVERFLOW
                MOV     AH,04AH         ;ASK FOR DEALLOCATION OF ALL BUT THIS
                INT     021H
                JNC     S1              ;IF CARRY BAD PROBLEM
                MOV     AX,OFFSET MS1   ;POINT AX AT MESSAGE 1
                JMP     END_ERROR       ;NOW LEAVE
S1:
                                ;AN ASSUMPTION IS MADE AT THIS POINT, THAT
                                ;THERE IS ENOUGH MEMORY FOR THE PROGRAM TO BE
                                ;EXEC'D TO OPERATE IN. IF NOT AN EXEC ERROR
                                ;WILL BE RETURNED.

                MOV     AX,OFFSET CR    ;FIND LENGTH OF COMMAND TAIL
                SUB     AX,OFFSET CMDL  ;AND
                MOV     CMDLEN,AL       ;PUT IT IN CMDLEN
                MOV     DX,OFFSET CMDL  ;FILL IN THE COMMAND TAIL POINTER IN
                                        ;THE PARAMETER BLOCK
                MOV     CMDLNLOW,DX
                MOV     CMDLNHI,DS
                MOV     DX,OFFSET PROGRAM ;POINT DX AT PROGRAM NAME
                MOV     ES,THIS_SEG     ;MAKE SURE ES IS POINTING AT THIS SEG
                MOV     BX,OFFSET PARMS ;POINT BX AT PARAMETER BLOCK
                MOV     AX,05CH         ;THIS IS OFFSET OF PARENT FCB1 BUT
                                        ;COULD BE ANY INFO DESIRED TO PASS TO
                                        ;CHILD THAT WOULD BE LOOKED FOR AT PSP
                                        ;5CH
                MOV     FCB11,AX        ;PUT IT IN PARAMETER BLOCK
                MOV     FCB12,ES        ;DESIRED SEGMENT OF FCB1 DATA
                MOV     AX,06CH         ;FILL IN FCB2. ABOVE COMMENTS APPLY
                MOV     FCB21,AX
                MOV     FCB22,ES
                MOV     AH,04BH         ;THE EXEC FUNCTION
                MOV     AL,0            ;LOAD AND EXECUTE
PREX:
                INT     021H            ;DOS
                JNC     FINISHED        ;ALL ACCORDING TO PLAN
                MOV     AX,OFFSET MS2   ;SOMETHING WRONG IN EXEC
                JMP     SHORT END_ERROR
FINISHED:
                MOV     AH,04DH         ;TO REACH HERE THE CHILD MUST HAVE
                                        ;TERMINATED. THIS REQUESTS THE
                                        ;TERMINATION CODE
                INT     021H            ;DOS TERMINATION CODE RETURNED IN AH
                                        ;CHILD'S AL PASSED THROUGH
                MOV     AH,04CH         ;TERMINATE THIS PROG
                INT     021H
END_ERROR:
                MOV     DX,AX           ;SAVE THE MESSAGE ADDRESS TO DX
                MOV     BX,1            ;DEVICE HANDLE IS CONSOLE
                MOV     CX,20           ;20 BYTES IS ENOUGH FOR THE MESSAGE
                MOV     AH,040H         ;WRITE TO DEVICE (CONSOLE)
                INT     021H            ;DOS
                MOV     AH,04CH         ;TERMINATE THIS PROGRAM
                INT     021H

PROG_END        LABEL   BYTE
CODE            ENDS
                END     ENTRY


                PAGE    60,132
                TITLE   EXMPLTSR.ASM - An example of a TSR program

COMMENT~*********************************************************************
*        --++**> This file is Copyright 1989 by David O'Riva <**++--        *
*****************************************************************************
*                                                                           *
* Written for the Microsoft Macro Assembler version 5.1, DOS v2.0 - 3.3     *
*                                                                           *
* MUST BE CONVERTED INTO A .COM FILE BEFORE RUNNING!!!                      *
*                                                                           *
*       Anyone who wants to incorporate this code into their programs is    *
* welcome to, as long as they don't try to sell this file as it is or any   *
* unmodified piece of it, and leave this message in when distributing it.   *
* If you do not abide by the rules, poltergeists will invade your home      *
* and chain letters and junk mail will arrive by the ton.                   *
*                                                                           *
*                                                                           *
*                  Short advertisement - use QEdit!                         *
*           Available on your local friendly Bulletin Board                 *
*                                                                           *
****************************************************************************~
.XLIST
;
; Macros used by this program
;

?PLevel         =       0

PNPROC          MACRO   PNAME           ;;declare near public procedure
                IF2
                %OUT    Routine: &PNAME
                ENDIF
                PUBLIC  &PNAME
&PNAME          PROC    NEAR
?PLevel         =       ?PLevel+1       ;;next level of nesting
@@SAVE_NAME     &PNAME,%?PLevel
                ENDM

PFPROC          MACRO   PNAME           ;;declare near public procedure
                IF2
                %OUT    Routine: &PNAME
                ENDIF
                PUBLIC  &PNAME
&PNAME          PROC    FAR
?PLevel         =       ?PLevel+1       ;;next level of nesting
@@SAVE_NAME     &PNAME,%?PLevel
                ENDM

ENDPROC         MACRO
@@REC_NAME      %?PLevel
@@EP1           %@@TEMP
?PLevel         =       ?PLevel-1
                ENDM

@@SAVE_NAME     MACRO   PNAME,LVL
?PN&LVL         EQU     <&PNAME>
                ENDM



@@REC_NAME      MACRO   LVL
@@TEMP          EQU     
                ENDM

@@EP1           MACRO   PNAME
&PNAME          ENDP
                ENDM

PUSHM           MACRO   LST
IRP             REG,<&LST&>
                PUSH    REG
                ENDM
                ENDM

POPM            MACRO   LST
IRP             REG,<&LST&>
                POP     REG
                ENDM
                ENDM

UPCASE          MACRO   REG
                LOCAL   NOUP
                CMP     REG,'a'
                JB      NOUP
                CMP     REG,'z'
                JA      NOUP
                SUB     REG,'a'-'A'
NOUP:
                ENDM

@CHANGE_VECT    MACRO   INUM,GARB,NEW,GARB2,SAVEAREA
                MOV     AX,0
                MOV     ES,AX
                MOV     AX,ES:[INUM*4]
                MOV     DX,ES:[INUM*4+2]
                MOV     WPTR CS:[SAVEAREA],AX
                MOV     WPTR CS:[SAVEAREA+2],DX
                MOV     AX,OFFSET CS:NEW
                CLI
                MOV     ES:[INUM*4],AX
                MOV     ES:[INUM*4+2],CS
                STI
                ENDM

@RESTORE_VECT   MACRO   INUM,GARB,SAVEAREA
                MOV     AX,WPTR CS:[SAVEAREA]
                MOV     DX,WPTR CS:[SAVEAREA+2]
                CLI
                MOV     DS:[INUM*4],AX
                MOV     DS:[INUM*4+2],DX
                STI
                ENDM

BPTR            EQU     
WPTR            EQU     
DPTR            EQU     
CR              EQU     <13>
LF              EQU     <10>
JR              EQU     


FALSE           EQU     <000H>
TRUE            EQU     <0FFH>

INT_CTRL        EQU     020H    ;Interrupt control port
EOI             EQU     020H    ;Reset interrupt controller command
KB_DATA         EQU     060H    ;Keyboard data port
KB_CTRL         EQU     061H    ;Keyboard control port
;
;****************************************************************************
;
BIOSDATA        SEGMENT AT 00040H

;----------------------------------------------------------------------------
;Keyboard Data Area
;----------------------------------------------------------------------------
                ORG     00017H
KB_FLAG         LABEL   BYTE

;----- Shift flag equates within KB_FLAG

        INS_STATE       EQU     80H     ;INSERT state is active
        CAPS_STATE      EQU     40H     ;CAPS LOCK state toggled
        NUM_STATE       EQU     20H     ;NUM LOCK state toggled
        SCROLL_STATE    EQU     10H     ;SCROLL LOCK state toggled
        ALT_SHIFT       EQU     08H     ;ALT key depressed
        CTRL_SHIFT      EQU     04H     ;CTRL key depressed
        LEFT_SHIFT      EQU     02H     ;left SHIFT key depressed
        RIGHT_SHIFT     EQU     01H     ;right SHIFT key depressed

                ORG     00018H
KB_FLAG_1       LABEL   BYTE

;----- Shift flag equates within KB_FLAG_1

        INS_SHIFT       EQU     80H     ;INSERT key depressed
        CAPS_SHIFT      EQU     40H     ;CAPS LOCK key depressed
        NUM_SHIFT       EQU     20H     ;NUM LOCK key depressed
        SCROLL_SHIFT    EQU     10H     ;SCROLL LOCK key depressed
        HOLD_STATE      EQU     08H     ;suspend key has been toggled

                ORG     00019H
ALT_INPUT       LABEL   BYTE            ;storage for alternate keypad entry

                ORG     0001AH
BUFFER_HEAD     LABEL   WORD            ;pointer to head of keyboard buffer

                ORG     0001CH
BUFFER_TAIL     LABEL   WORD            ;pointer to tail of keyboard buffer

                ORG     0001EH
KB_BUFFER       LABEL   WORD            ;keyboard buffer

                ORG     0003EH
KB_BUFFER_END   LABEL   WORD
                                       ;
;----- HEAD = TAIL indicates that the buffer is empty

        NUM_KEY         EQU     69      ;scan code for NUM LOCK
        SCROLL_KEY      EQU     70      ;sc for SCROLL LOCK


        ALT_KEY         EQU     56      ;sc for ALT key

BIOSDATA        ENDS

.list
.lall
;
;****************************************************************************
;
CODE            SEGMENT PARA PUBLIC 'CODE'
                ASSUME  CS:CODE,DS:CODE,ES:CODE,SS:CODE

                ORG     02CH
ENVIRONMENTSEG  LABEL   WORD

                ORG     100H
MAIN            PROC    FAR

STACKTOP:                               ;allow the stack to overwrite the
                                        ;command line in the PSP
ENTRY:          JMP     INSTALL

;============================================================================
;
; MY LOCAL DATA
;

MCBOVL          STRUC                   ;definition of DOS's memory control
;                                       ;block structure
MCB_KIND        DB      ' '
MCB_PSP_ADDR    DW      0
MCB_LENGTH      DW      0
MCB_UNDEFINED   DB      11 DUP(?)
;
MCBOVL          ENDS

  m@BLOCK       EQU     <'M'>           ;possible entries in the MCB_TYPE field
  m@LAST        EQU     <'Z'>

OLD9            DD      ?               ;old INT 09H vector
OLD08           DD      ?
OLD28           DD      ?
OLD69           DD      ?

InDOS           DD      ?               ;address of the InDOS flag
CODSEG          DW      ?               ;code segment

AllowPop        DB      FALSE           ;TRUE = the INT 09H server is allowed
                                        ;       to try to run the TSR.

TryPop          DB      FALSE           ;TRUE = The INT 09H server couldn't
                                        ;       run the TSR because DOS was
                                        ;       processing a command at the
                                        ;       time.
                                       ;
InPop           DB      FALSE           ;TRUE = the popped-up code is running
                                        ;       at the moment.

OLDSS           DW      ?               ;storage for stack frame information
OLDSP           DW      ?



PopShifts       DB      LEFT_SHIFT+RIGHT_SHIFT  ;shift state necessary for
                                                ;  pop-up

PopKey          DB      14H             ;key # to press to pop up ('T')

;============================================================================


                PAGE
;****************************************************************************
; START - main program loop
;
;
;     ENTRY:    from hot key
;
;      EXIT:    nothing
;
; DESTROYED:    none
;
;----------------------------------------------------------------------------
PNPROC          START

;------------------------------------------------------------------------------
; set up my stack frame
;------------------------------------------------------------------------------
                MOV     CS:OLDSS,SS
                MOV     CS:OLDSP,SP
                CLI
                MOV     SS,CS:CODSEG
                MOV     SP,OFFSET STACKTOP
                STI
                PUSH    AX

;------------------------------------------------------------------------------
; MAIN LOOP
;------------------------------------------------------------------------------
                CALL    BEEP
GETAKEY:
                MOV     AH,0            ;get a key
                INT     016H
                UPCASE  AL

                CMP     AL,'N'          ;'N' for NUKE THE TSR!
                JNE     NOT_NUKE

                CALL    UNLOAD          ;try to unload myself
                JNC     LEAVE
                CALL    BEEP            ;string of beeps if I can't
                CALL    BEEP
                CALL    BEEP
                JMP     GETAKEY

NOT_NUKE:       CMP     AL,'Q'          ;'Q' for quit TSR
                JE      LEAVE
                                       ;
                CALL    BEEP            ;unrecognized key, complain
                JMP     GETAKEY         ;... and get another

LEAVE:          POP     AX              ;recover * ALL * modified registers


                                        ;        -------
;------------------------------------------------------------------------------
; recover original stack frame
;------------------------------------------------------------------------------
                CLI
                MOV     SS,CS:OLDSS
                MOV     SP,CS:OLDSP
                STI

                RET
ENDPROC


                PAGE
;******************************************************************************
; BEEP - Beeps the speaker
;
;
;     ENTRY:    nothing
;
;      EXIT:    nothing
;
; DESTROYED:    none
;
;------------------------------------------------------------------------------
PNPROC          BEEP

                PUSH    AX
                PUSH    CX
                MOV     AL,10110110B
                OUT     043H,AL
                MOV     AX,1000
                OUT     042H,AL
                MOV     AL,AH
                OUT     042H,AL

                IN      AL,061H
                MOV     AH,AL
                OR      AL,3
                OUT     061H,AL
                SUB     CX,CX
                LOOP    $
                MOV     AL,AH
                OUT     061H,AL
                POP     CX
                POP     AX
                RET
ENDPROC


;                PAGE
;;****************************************************************************
;; REGISTERTOTEXT - Converts AL into ASCII hex digits in CS:[SI]
;;
;;       For debugging - uncomment this routine if you need it.
;;                                    ;
;;     ENTRY:    AL = register to translate
;;               SI = place to put translated digits
;;
;;      EXIT:    AX = hex digits


;;
;; DESTROYED:    AX
;;
;;----------------------------------------------------------------------------
;ASSUME ds:NOTHING,es:NOTHING
;PNPROC          REGISTERTOTEXT
;;----------------------------------------------------------------------------
;; split AL into two nibbles
;;----------------------------------------------------------------------------
;                MOV     AH,AL
;                SHR     AH,1
;                SHR     AH,1
;                SHR     AH,1
;                SHR     AH,1
;                AND     AL,0FH
;;----------------------------------------------------------------------------
;; convert AL into a hex digit
;;----------------------------------------------------------------------------
;                ADD     AL,'0'                  ;AL = actual digit
;                CMP     AL,'9'
;                JBE     R_1
;                ADD     AL,'A'-'0'-10
;;----------------------------------------------------------------------------
;; convert AH into a hex digit
;;----------------------------------------------------------------------------
;R_1:            ADD     AH,'0'                  ;AH = actual digit
;                CMP     AH,'9'
;                JBE     R_2
;                ADD     AH,'A'-'0'-10
;;----------------------------------------------------------------------------
;; store hex number in [SI]
;;----------------------------------------------------------------------------
;R_2:            MOV     CS:[SI],AH
;                MOV     CS:[SI+1],AL
;                RET
;ENDPROC
;

                PAGE
;****************************************************************************
; TRAPPER9 - Intercepts the incoming keyboard scan code
;
;       Looks for the hot key in the incoming scan codes.  If found, it
; check the InDOS flag to see if DOS is currently in the middle of something.
; If not, the TSR code (at START) is invoked.  Otherwise, a flag is set and
; control is passed back to DOS.
;
;     ENTRY:    from IRQ 1, machine state is ???
;
;      EXIT:    continues KB interrupt chain
;
; DESTROYED:    ALL PRESERVED
;
;----------------------------------------------------------------------------
ASSUME ds:BIOSDATA,es:NOTHING
PFPROC          TRAPPER9
                PUSHM      ;save everthing I use

                MOV     AX,SEG BIOSDATA ;DS-> BIOS's data seg
                MOV     DS,AX


;----------------------------------------------------------------------------
; are we in the correct shift state?
;----------------------------------------------------------------------------
                MOV     AL,KB_FLAG      ;get current shift states
                AND     AL,00FH         ;clean up the byte
                CMP     AL,CS:PopShifts ;is it the right shift?
                JNE     T_chainon       ;no, go to next handler

                IN      AL,KB_DATA      ;Poll keyboard controller
                MOV     BH,AL           ;save keypress
                AND     AL,07FH         ;strip off the MAKE/BREAK bit
                CMP     AL,CS:PopKey    ;is this our key?
                JNE     T_ChainOn       ;If it's not our code, ignore it...
;----------------------------------------------------------------------------
; reset the keyboard controller
;----------------------------------------------------------------------------
                IN      AL,KB_CTRL      ;get multi-purpose control byte
                MOV     AH,AL           ;save original value
                OR      AL,080H         ;set "character recieved" bit
                OUT     KB_CTRL,AL      ;send it
                MOV     AL,AH           ;get original value back
                OUT     KB_CTRL,AL      ;send it
;------------------------------------------------------------------------------
; what do we do with this key?
;------------------------------------------------------------------------------
                CMP     CS:AllowPop,FALSE ;Are we allowed to pop up now?
                JE      T_ResetLeave    ;if not, exit here...

                TEST    BH,080H         ;was it the BREAK code?
                JZ      T_WasMake       ;no, go run the pop-up
                JMP     T_ResetLeave    ;otherwise, ignore this code

T_WasMake:      MOV     CS:AllowPop,FALSE ;can't pop up again

                PUSHM            ;check the InDOS flag...
                LES     BX,CS:InDOS
                CMP     BPTR ES:[BX],0
                POPM    

                JNZ     T_InDOSnow      ;if in DOS, don't invoke TSR

                MOV     AL,EOI          ;otherwise, set interrupts on...
                OUT     INT_CTRL,AL
                MOV     CS:InPop,TRUE   ;...set a flag...
                STI
                CALL    START           ;...and run the TSR.
                CLI
                MOV     CS:AllowPop,TRUE
                MOV     CS:InPop,FALSE
                JMP     T_Leave

T_InDOSnow:     MOV     CS:TryPop,TRUE  ;DOS call in progress, try later...
                                       ;
T_ResetLeave:   MOV     AL,EOI          ;enable the KB interrupt again
                OUT     020H,AL
T_Leave:        POPM       ;throw away this key code
                IRET
;----------------------------------------------------------------------------
; Continue down the KB handler chain...
;----------------------------------------------------------------------------


T_chainon:      POPM    
                JMP     DWORD PTR CS:OLD9
ENDPROC



                PAGE
;******************************************************************************
; TRAPPER08 - Intercepts the timer tick to try to pop up the TSR
;
;       Upon being called, this routine determines whether:
;               a) the TSR wants to pop up, and
;               b) there is no DOS call in progress
;       If these are BOTH true, then the TSR is invoked from here.
;
;       NOTE: Technically, you are supposed to trap vector 1CH for timer
; ticks instead of INT 08, but some BIOSes do not issue an EOI for the timer
; until AFTER 1C is called, and you don't want to mess up the system clock...
;
;     ENTRY:    on timer tick
;
;      EXIT:    nothing
;
; DESTROYED:    ALL PRESERVED
;
;------------------------------------------------------------------------------
PFPROC          TRAPPER08
ASSUME ds:NOTHING,es:NOTHING

                PUSHF
                CALL    DWORD PTR CS:[OLD08]

                CLI

                CMP     CS:TryPop,FALSE ;Are we trying to pop up?
                JE      C_OUT           ;if not, leave now

                PUSHM            ;Is a DOS call in progress?
                LES     BX,CS:InDOS
                CMP     BPTR ES:[BX],0
                POPM    

                JE      C_Invoke        ;if not, then fire it up...

C_OUT:          IRET

C_Invoke:       MOV     CS:TryPop,FALSE ;set the right flags...
                MOV     CS:InPop,TRUE
                STI
                CALL    START           ;run the TSR...
                MOV     CS:InPop,FALSE  ;set some more flags...
                MOV     CS:AllowPop,TRUE
                                       ;
                IRET                    ;and leave.
ENDPROC


                PAGE
;******************************************************************************
; TRAPPER28 - Intercepts the DOS "console wait" loop


;
;       This routine allows the TSR to be invoked during DOS console operations
; where the InDOS flag is set but it is actually safe to use any DOS function
; above 0CH.
;
;     ENTRY:    During DOS console operations
;
;      EXIT:    nothing
;
; DESTROYED:    ALL PRESERVED
;
;------------------------------------------------------------------------------
ASSUME ds:NOTHING,es:NOTHING
PFPROC          TRAPPER28

                CMP     CS:TryPop,FALSE ;does the TSR want to pop up?
                JE      C1_OUT          ;if not, get out of here now
                MOV     CS:TryPop,FALSE ;prevent re-entrant interrupts
                MOV     CS:InPop,TRUE   ;set the "in TSR" flag
                STI
                CALL    START           ;run it!
                CLI
                MOV     CS:AllowPop,TRUE;finished, we can pop up again
                MOV     CS:InPop,FALSE  ;no longer running the TSR
C1_OUT:         JMP     DWORD PTR CS:OLD28 ;continue down the console chain
ENDPROC


                PAGE
;******************************************************************************
; TRAPPER69 - Chains to INT 69H so we can determine if the TSR's already here
;
;       This routine provides a method of checking to see whether a copy of
; this TSR already exists in memory.  This entry could also be used to
; reconfigure the resident portion of the program (i.e. to reset a clock,
; to add a file to a print queue... etc.)
;
;     ENTRY:    AX = 0ABCDH
;
;      EXIT:    If the TSR is already resident:
;                       AX = 0DCBAH
;
;               If the TSR is NOT resident:
;                       AX = 0ABCDH
;
; DESTROYED:    AX if resident
;
;------------------------------------------------------------------------------
ASSUME ds:NOTHING,es:NOTHING
PFPROC          TRAPPER69
                                         ;
                CMP     AX,0ABCDH               ;Is it the correct function?
                JE      CK_OURS                 ;yes, respond to it
                JMP     DWORD PTR CS:OLD69
CK_OURS:        MOV     AX,0DCBAH               ;set return code
                IRET
ENDPROC


                PAGE


;****************************************************************************
; UNLOAD - Unhooks all vectors and exits
;
;       This routine removes the TSR from memory, if possible.  The sequence
; of events is:
;       a) a check is made to be sure that we are the LAST program in memory
;       b) all vectors are unhooked
;       c) the environment segment that DOS gave me is deallocated
;       d) the current code segment is deallocated
;       e) control is returned to whatever program was running before
;
;     ENTRY:    nothing
;
;      EXIT:    nothing
;
; DESTROYED:    this program, hopefully
;
;----------------------------------------------------------------------------
ASSUME ds:CODE,es:CODE
PNPROC          UNLOAD

;------------------------------------------------------------------------------
; see if there are active memory control blocks after mine
;------------------------------------------------------------------------------
                PUSH    AX
                PUSH    ES
                MOV     AX,CS                   ;my MCB starts 1 seg before
                DEC     AX                      ;  my code seg
                MOV     ES,AX
                ADD     AX,ES:[0].MCB_LENGTH    ;find out how long it is
                INC     AX                      ;fiddle the value
                MOV     ES,AX
                MOV     AL,ES:[0].MCB_KIND      ;what kind is the next MCB?
                CMP     AL,m@LAST               ;if it's not the last...
                POP     ES
                POP     AX
                JNZ     BAD_UNLOAD              ;...then leave now
;------------------------------------------------------------------------------
; unhook all the vectors
;------------------------------------------------------------------------------
                PUSH    AX
                PUSH    DX
                PUSH    ES
                PUSH    DS
                MOV     AX,0
                MOV     DS,AX
                @RESTORE_VECT 009H FROM OLD9    ;Restore keyboard vector
                @RESTORE_VECT 008H FROM OLD08   ;Restore timer vector
                @RESTORE_VECT 028H FROM OLD28   ;Restore console vector
                @RESTORE_VECT 069H FROM OLD69   ;Restore my TSR vector
;------------------------------------------------------------------------------
; deallocate everything
;------------------------------------------------------------------------------
                MOV     ES,CS:ENVIRONMENTSEG
                MOV     AH,049H                 ;de-allocate the environment
                INT     021H                    ;  block
                PUSH    CS
                POP     ES
                MOV     AH,049H                 ;de-allocate the code block
                INT     021H


                POP     DS
                POP     ES
                POP     DX
                POP     AX
                CLC
                RET
;------------------------------------------------------------------------------
;can't unload: memory control blocks after mine...
;------------------------------------------------------------------------------
BAD_UNLOAD:     STC
                RET

ENDPROC


                PAGE
;****************************************************************************
; INSTALL - Installs traps, then runs the program.
;
;     ENTRY:    called on entry to the program
;
;      EXIT:    TSR's the main program and exits to DOS
;
; DESTROYED:    ALL
;
;----------------------------------------------------------------------------
ASSUME ds:CODE,es:CODE
PNPROC          INSTALL
                PUSH    CS
                PUSH    CS
                POP     DS
                POP     ES
                MOV     CS:CODSEG,CS
;------------------------------------------------------------------------------
; see if this program is already in memory
;------------------------------------------------------------------------------
                MOV     AX,0ABCDH
                INT     069H
                CMP     AX,0DCBAH
                JNE     NOT_THERE
                JMP     ALREADY_THERE
;----------------------------------------------------------------------------
; install our keyboard hardware interrupt trap
;----------------------------------------------------------------------------
NOT_THERE:      MOV     AllowPop,FALSE
                MOV     TryPop,FALSE
                MOV     AX,03400H               ;get the InDOS flag's address
                INT     21H
                MOV     WPTR CS:InDOS,BX        ;...and save it
                MOV     WPTR CS:InDOS[2],ES
                @CHANGE_VECT 009H TO TRAPPER9 SAVEIN OLD9
                @CHANGE_VECT 008H TO TRAPPER08 SAVEIN OLD08
                @CHANGE_VECT 028H TO TRAPPER28 SAVEIN OLD28
                @CHANGE_VECT 069H TO TRAPPER69 SAVEIN OLD69
;----------------------------------------------------------------------------
; print copyright notice
;----------------------------------------------------------------------------
                MOV     AH,9
                MOV     DX,OFFSET NOTICE
                INT     021H


                MOV     CS:AllowPop,TRUE
;------------------------------------------------------------------------------
; calculate total program size and leave
;------------------------------------------------------------------------------
TSR_OUT:        MOV     AX,03100H
                MOV     DX,OFFSET INSTALL
                SHR     DX,1
                SHR     DX,1
                SHR     DX,1
                SHR     DX,1
                INC     DX
                INT     021H
;------------------------------------------------------------------------------
; ERROR: program is already resident!
;------------------------------------------------------------------------------
ALREADY_THERE:  MOV     AH,9
                MOV     DX,OFFSET ALREADY
                INT     021H
                MOV     AX,04C01H
                INT     021H
ENDPROC

;==============================================================================
; DATA THAT'S ONLY USED DURING INSTALLATION
;
;

NOTICE          LABEL   BYTE
DB CR,LF
DB 'Example TSR         v1.0  Sun  03-19-1989',CR,LF
DB 'Copyright (C) 1988 ORivation',CR,LF
DB CR,LF
DB 'Press LSHIFT-RSHIFT-T to execute',CR,LF,'$'
ALREADY         LABEL   BYTE
DB CR,LF,'The Example TSR is already installed!',7,CR,LF,'$'

MAIN            ENDP
;
;****************************************************************************
;
CODE            ENDS
                END     ENTRY

;;;;;;;;;;;;;;;;;

THE ASSEMBLY LANGUAGE "MAGAZINE"                  VOL 1 NUMBER 3
                                                  May, 1989

















  ##     ####    ####   ####### ##   ## ######  ####    ##  ##
 ####   ##  ##  ##  ##   ##   # ### ###  ##  ##  ##     ##  ##
##  ##  ###     ###      ## #   #######  ##  ##  ##     ##  ##
##  ##   ###     ###     ####   #######  #####   ##      ####
######     ###     ###   ## #   ## # ##  ##  ##  ##   #   ##
##  ##  ##  ##  ##  ##   ##   # ##   ##  ##  ##  ##  ##   ##
##  ##   ####    ####   ####### ##   ## ######  #######  ####
  
        ####      ##    ##   ##   ####  ##  ##    ##      ####  #######
         ##      ####   ###  ##  ##  ## ##  ##   ####    ##  ##  ##   #
         ##     ##  ##  #### ## ##      ##  ##  ##  ##  ##       ## #
         ##     ##  ##  ## #### ##      ##  ##  ##  ##  ##       ####
         ##   # ######  ##  ### ##  ### ##  ##  ######  ##  ###  ## #
         ##  ## ##  ##  ##   ##  ##  ## ##  ##  ##  ##   ##  ##  ##   #
        ####### ##  ##  ##   ##   ##### ######  ##  ##    ##### #######



















Written by and for assembly language programmers.






                         Table of Contents

        Table of Contents. . . . . . . . . . . . . . . . . . . . . . 2

        Editorial. . . . . . . . . . . . . . . . . . . . . . . . . . 3

        GUIDE LINES FOR CONTRIBUTORS . . . . . . . . . . . . . . . . 4

        Beginners'Corner . . . . . . . . . . . . . . . . . . . . . . 5
          Segmentation . . . . . . . . . . . . . . . . . . . . . . . 5

        Keyboard driven TSR programs.. . . . . . . . . . . . . . . . 7

        Hex Conversion Routines . . . . . . . . . . . . . . . . . . 12

        Book Reviews. . . . . . . . . . . . . . . . . . . . . . . . 14

        Source Code for Keyboard TSR. . . . . . . . . . . . . . . . 15

        Source for Soft Breakout. . . . . . . . . . . . . . . . . . 18







































;page 2




                                      Editorial

                This is the third issue of the Magazine, and the first with a
        major article from an outside contributor.  Our thanks to Garrett
        Nievin.

                It is amazing how few programmers really appreciate
        the benefits of assembly language programming.  Most of them under-
        stand that for certain parts of programs it can increase performance,
        but they have no real conception of the amount of improvement that it
        can make.

                As a common example of this-- The case of sprite
        manipulation.  Some of the more speed conscious programmers are
        aware that to do clean writes to the CGA screen you need to wait
        for the retrace periods, but a C programmer cannot chase the
        electron beam around the screen to update it in areas that will
        not be affected until it again goes over it.  This multiplies the
        time available to manipulate areas of the screen without flicker.

                Much of the time in executing a higher level routine is
        spent in calling it and returning from it.  The indexed with of-
        fset stack operations are very costly in time.  This is why even
        speedup assembly routines in high level code don't show the full
        capabilities as they are still called using the same conventions.

                One of the most touted buzz words today is "structured".
        This translates into using small easily controlled and understood
        subroutines with a single entry point and a single exit point
        having sharply limited function. This makes for a program that is
        quick and easy to write (regardless of the language) and quick to
        debug. These are all valuable attributes in a program, and if
        done right these same routines can be included in a large variety
        of dissimilar programs.

                There are those who say that any programmer who does not
        keep to "structured" programming is a bad programmer.  At least in
        assembly language programming there are times and reasons for
        throwing this whole concept away.  In doing so you create a
        program that is almost impossible to modify, totally unreadable,
        insane to debug, and a nightmare to try and document----BUT----you
        can also come close to cutting your size (already tiny compared to
        anything else) in half and have a good chance of a thirty percent
        increase in speed if you do it right.  A program like that is not
        the product of a "bad" programmer, but of a very dedicated one.
        In such a program you don't have the time to waste making a lot of
        CALLS or doing variable storage or register adjustments.  The num-
        ber of items that you must keep track of, mostly in your head,
        while writing makes it a project for only the best of programmers.
        I gave it up years ago, but still envy those who are able to make
        use of a powerful tool.









;page 3



                  GUIDE LINES FOR CONTRIBUTORS AND 'ADVERTISERS'


                 Name and address must be included with all articles and
        files.  Executable file size and percent of assembly code (when
        available) should be included when a program is mentioned and is re-
        quired from an author or publisher.  Any article of interest to
        Assembly language programmers will be considered for inclusion.
        Quality of writing will not be a factor, but I reserve the right to
        try and correct spelling errors and minor mistakes in grammar, and to
        remove sections.

                Non-exclusive copyright must be given.  No monetary compensa-
        tion will be made.

                 Outlines of projects that might be undertaken jointly are
        welcome.  For example:  One person who is capable with hardware needs
        support from a user friendly programmer and a math whiz.

                 Advertisements as such are not acceptable.  Authors and
        publishers wishing to contribute reviews of their own products will be
        considered and included as space and time permit.  These must include
        executable file size, percent of assembly code and time comparisons.

                 Your editor would like information on math libraries, and
        reviews of such.

                 Articles must be submitted in pclone readable format or sent
        E-mail.


                 Money:  Your editor has none.  Therefore no compensation can
        be made for articles included.  Subscription fees obviously don't ex-
        ist.  Publication costs I expect to be nil (NUL).  Small contributions
        will be accepted to support the BBS where back issues are available as
        well as files and programs mentioned in articles(if PD or Shareware
        ONLY).

                 Shareware-- Many of the programs mentioned in the "Magazine"
        are Shareware. Most of the readers are prospective authors of programs
        that can be successfully marketed as Shareware.  If you make significant
        use of these programs the author is entitled to his registration fee or
        donation.  Please help Shareware to continue to be a viable marketing
        method for all of us by urging everyone to register and by helping to
        distribute quality programs.












;page 4



        Beginners'Corner

                                  Segmentation

                 Segments are largely a carry over from the days when
        processors were all limited to a 16 bit address buss, but we still
        live with them today.  They are not without some benefits however.
        The way they are treated in most of the books I am familiar with
        can leave the novice fear struck over the complexities and this is
        not necessary.  They are nothing more ( to the assembly program-
        mer) than a tool that can either be used or discarded almost at
        will.

                The 8088 has 4 segment registers; CS, DS, ES, and SS.  The
        complete address of a memory reference is the sum of the segment
        register (shifted 1 hex place to the left) and another register.
        Thus each location in memory can be accessed by many (up to 4096)
        combinations of segment and offset.  For example segment 1000h,
        offset 1000 (generally written as 1000:1000) can also be addressed
        as 1001:0ff0, as the sum of both of these add up to 11000h.  Each
        of the segment registers has another register that is hardware as-
        sociated with it but that can sometimes be overridden in the in-
        struction.  The IP (instruction pointer) is firmly attached to the
        CS segment.  The SP (stack pointer) always points to a location in
        the SS (stack segment).  DI refers mainly to a location in ES
        as SI does to DS.
                In standard programming parlance there is the code
        segment, the stack segment, and the data segment written in
        various ways such as code_seg. High level language compilers
        insist on this division and MASM forces you to at least define
        them, but you should keep in mind that they are only conveniences
        and should be discarded when they cease to be convenient.
                In the following discussion I want to make a distinction
        between two types of data. The first is data that the program
        contains or uses as intermediate storage. This would include
        variables addressed in the code, messages to the user, and data
        buffers that operated on. The second type is external to the
        program. An example of this is a text file that your program will
        edit. Let me call the first type program data and the second type
        external data. The dividing line is very loose and often ceases
        to exist but it is a convenient fiction for now.
                The one unchangeable fact that we have to deal with is the
        way DOS loads the programs. There are two formats it can
        follow: the .COM  format and the .EXE format. The COM format loads
        quickly because it is simply an image of the machine code and
        needs no processing by DOS in order to execute. It is limited in
        size to 64k, but I have never seen an assembly language program
        that was that large so it is really not much of a limit. All
        segment registers are set to the same value on loading (this
        value is the address of the PSP) and the IP
        is set at 100h.
                The EXE format is not limited to size but it requires post
        processing by DOS in order to work. This makes it slower to begin
        execution. This is also the format that is compatible with the
        source level debuggers. During linking the linker assigns segment
        offset values to each of the segments you define in your code.
        After loading DOS adds this offset value to each location in your

 ;page 5


        code that addresses a segment. This information is contained in a
        relocation table that the linker prepends to the file. Then DOS
        sets the CS register to the start of your code segment and the SS
        register to the start of your stack segment, and DS and ES to the
        start of the PSP. The IP is set to the offset specified in the END
        statement as the start of execution.
                Using either format you are still left with a mess to
        attend to. Your program data area is not defined or addressed,
        your stack is out of control (if .COM), and your program owns the entire
        address space in the computer from the start of your program to
        the end of memory. The first responsibility of any program is to
        clean this up. The methods of doing this are very simple and can
        be s standard header to all of your programs. I won't go into them
        now, but will try to cover them next issue. For now let's assume
        that you have attended to that and your whole program with code,
        stack and program data occupy a few thousand bytes above the
        PSP,and you have returned everything else to DOS. This is the
        ideal starting point for any program. Whatever other memory you
        need for external data can be requested from DOS and it knows how
        much is there and unused which your program doesn't. It will
        return to you the segment address of the block you requested. This
        then you can subdivide into as many segments as you like. For
        example: you are keeping a database of 10,000 names. Each name
        could be considered to be 2 segments long (32 characters) so you
        could move from name to name by adding 2 to the segment register
        you are using to address this space. Doing it this way frees you
        from the 64k limit you would have if instead you used one of the
        index registers and added 32 to it.
                This is a complex subject to try and explain, especially
        in a short column. More techniques will be discussed next issue.




























;page 6



                A fool rambles about Keyboard driven TSR programs.
                                     by
        Garrett P.  Nievin 4518 Valley Brook Dr.  San Antonio, TX 78238

                                o Introduction

            First of all, let me describe exactly how a keyboard driven TSR
        SHOULD work, to be a friendly inhabitant of your system.  To me,
        there are two kinds of such programs:  those which modify keyboard
        functioning (as in the case of Superkey), and those which merely
        check for keystrokes to activate a resident function (such as
        Sidekick).  I will focus my discussion on the latter, but the
        basic principles apply to any keyboard TSR.

           o Narrative of how a friendly TSR handles the keyboard.

            To reliably and safely monitor the keyboard for a keypress, a
        program must install an interrupt handler for interrupt 9, which
        is hardware generated every time a key is pressed or released.
        For now let's assume we have a routine in memory and is the active
        interrupt 9 handler.  Every time a key is pressed or released, our
        program automagically wakes up.  The only affected registers are
        CS:IP, which point to where our program is executing of course.
        Our program should IN a byte from the keyboard port; this is the
        scancode which we have been summoned to service.  Since the TSR
        program is only checking for a certain keyboard condition (such as
        an Alt-Q being hit), all other conditions should be ignored.  If
        it is not "our" key, then we want to do nothing more.  To relin-
        quish control, we do a long JMP to the old interrupt 9 handler
        (which may be BIOS ROM, or it may be another TSR.  In this friend-
        ly manner, any number of TSR's may happily coexist).  If it IS our
        key, we perform whatever action is appropriate, and terminate by
        one of two methods:  jump to the old int handler, which allows the
        rest of the TSR's and/or BIOS to get at the same keypress; or,
        terminate the interrupt ourselves.  This second method involves 3
        basic steps:  1) Tell the keyboard we have serviced his keypress
        2) Tell the hardware interrupt controller we have serviced the
        hardware interrupt to completion and 3) perform and IRET (return
        from interrupt) instruction to continue with system processing.

                          o How to read the keyboard

            The keyboard is driven by an 8048 chip, which is tied logically to
        the 8259A Peripheral Interrupt Controller (as level 1; only the
        timer interrupt at level 0 has more priority) and to the port A
        and port B of the 8255A-5 Programmable Peripheral Interface chip.
        I only give you these numbers to impress people with; that, and to
        get a little better understanding of what all happens.  The scan
        code of a keypress gets placed in port A of the 8255, which is
        mapped to I/O port 60h of the CPU.  All keypress scancodes will be
        in the range 01 (Escape) to 53h (Delete).  If the high bit is set
        on, then it is not a keypress scancode, but a key release scan-
        code.  These are usually ignored, but must be processed non-
        etheless.



        ;page 7
        

            Port A can be safely IN'd from any number of times before the
        keyboard is cleared; this is done by getting port B (IN AL,61h),
        set the hi bit on (OR AL,80h) and outing it back to port B.  Once
        the keyboard is cleared, you usually want to tell the 8259 PIC
        that the interrupt you've been servicing has been completed by
        outing 20h to port 20h.  The 8259 prioritizes all interrupts, and
        this command tells it that the highest priority interrupt is
        finished; this is neat because all the interrupt handlers don't
        have to know what level interrupt they are.

            Now comes the obvious question:  How are we going to check for 2
        keys, as in the case of say Alt Q?  BIOS makes this one easy.  In
        the BIOS/DOS data area (segment 40), at bytes 17h and 18h, we find
        information on which special keys are being pressed.  The sig-
        nificant bits are:

           17h xxxxXXXX 18h XXXXxxxx 1 Alt is being pressed 1 Insert
           is being pressed 1 Ctrl 1 Caps Lock 1 Left shift 1 Num
           Lock 1 Right shift 1 Scroll Lock

            All we do is wait for the scancode of Q to come up.  Then we check
        the appropriate bit in the appropriate flag byte (in the case of
        alt, we would test 0040:0017h for 08h).  If the bit is on, we do
        our thing.  Otherwise we just pass control on to the next in-
        terrupt handler in the string with our long JMP.  NOTE:  always
        use a "normal" key as a "wakeup call"; that is, don't check for
        combos like ALT-Rshift.  There are too many programs already that
        do this, and programs employing these keys are difficult to chan-
        ge, thereby ensuring incompatibilities.  In fact, if you dis-
        tribute your program and don't offer some means of "hot key" con-
        figuration, you may want to tell your users where your scan codes
        are located in the program so they may patch them themselves to
        avoid incompatibilities.  Hint:  use a CMP and not a TEST to check
        this byte, or if you are looking for ctrl-A then ctrl-alt-A,
        ctrl-shift-A, etc.  will all mistakenly trigger your interrupt.

                           o How to install the TSR

            The installation program will consist of 3 parts really:  the jump
        around the interrupt handler code to the install code, and the in-
        terrupt and install code areas.  The install code should do basi-
        cally two things:  install the interrupt handler using service 25h
        of interrupt 21h (DOS call), and of course
        terminate and-stay-resident.  To do the install, load AX with 2509h
        (AL has the interrupt number) and DS:DX with the address of the
        interrupt handler code, and do an int 21h.  Your program is RIGHT
        NOW the new interrupt 9 handler.  Then, load AX with 3100h and do
        an int 21h again (Terminate and stay res and return an err code of
        00 to parent).  At this point the handler is working, in memory,
        and control is released back to the parent program (in most cases
        Command.com).

            Here is our opportunity to start getting fancy.  To keep memory
        usage to a minimum, we should do a DOS service 4Ah to release all
        unneeded memory.



        ;page 8
        

           /* UPDATE:  I don't know what I was thinking here, but
           that's wrong.  You don't use service 4Ah in a TSR; it
           would do nothing.  What you DO do is load the number of
           paragraphs you need to keep into the DX register when you do
           your service 31h call.  The way I get that is to use:
           ((last_address-first_address)/16)+1 (to div by 16 just shift
           right 4 bits) And don't forget to allow room for your PSP!  */

            To REALLY cut down on the memory, we can relocate our program
        backwards into the unused PSP area, saving something like 164
        bytes.  Also, we can leave a memory signature so that the user is
        not allowed to install the TSR more than once.  My usual method of
        this is pretty simplistic.  I put 4 unique bytes into the TSR it-
        self, and then upon installation check if those bytes are there.
        If so, the installation aborts and the user is told.  The flaw
        here is that it only prevents the same program being installed
        after itself.  If such a TSR is loaded and takes int 9, another
        one is later loaded and takes int 9 also, the program could then
        be installed for the second time.  I know how my system is con-
        figured, so this is no problem.  To a novice user getting hold of
        one of my programs, this will at best just waste a little memory.
        At worst, the system can get a little weird.  To more securely
        guard against re-installation, you may take another interrupt vec-
        tor (there are 256, after all, and only a couple dozen are used in
        a basic PC).  The way that works is:  search for an empty in-
        terrupt vector (one which has all zeros), and take one when you
        find it.  Save a memory signature there.  When the program in-
        stalls the TSR code, search the interrupt vectors for your memory
        signature.  If you find it, you know your program is there al-
        ready.  Much safer.  (Aside:  For my personal use, I combine all
        my TSR's into one program.  This saves memory, time, and trouble.
        It also keeps me from installing TSR's in between one another!)

                    o What you can get away with in a TSR

            If you have read this far, I assume you don't already know all
        this.  So, I will not go into all the undocumented MS-DOS services
        for TSR writers.  If you are interested in them, I suggest you
        check back issues of magazines like Programmer's Journal and Dr.
        Dobb's.  Anyway, you are restricted as to what can happen inside a
        TSR.  It all boils down to one thing:  MS-DOS is not reentrant.
        It is not meant to be multitasking (under programs like DoubleDos,
        there are copies of DOS for each task running), and so a routine
        can not be called while it is already executing for somebody else.
        Here is a scenario:  You are saving a document from your word
        processor, and during the wait call up a TSR to find a phone num-
        ber or something.  The TSR does a disk read of your phone # file.
            The TSR finishes and exits back to the word processor.  Now, the
        WP's disk write has been interrupted, losing vital information
        like where on the disk he was writing, etc.  MS-DOS goes awry.  It
        is time for the big red switch, and kiss your document adios.
        Hope your disk is not messed up as well.

            There is the why of all this, now here is the what.  A TSR may not
        use any DOS int 21h services higher than 0Ch.  It is restricted to
        console and printer I/O services.  (Now, this is of course not
        TOTALLY true, but how to do disk I/O etc.  are beyond the scope of
        this little rambling.  Maybe some other time.)

        ;page 9
        

           /* UPDATE Okay, here's how to do anything you please from
           within a TSR, including disk I/O.  The BEST way is to install
           interrupt "front-end" handlers for int 13h (BIOS disk I/O),
           int 21h (DOS), int 25h (absolute disk read), int 26h (absolute
           disk write), and I think that's all.  In these front-end hand-
           lers, set a flag (or semaphore or TS byte or whatever you want
           to call it) whenever anyone is in the middle of a disk I/O.
           Then, in your TSR, don't do a disk I/O if any of these flags
           are set.  You will also need to steal the user timer tick in-
           terrupt (1Ch) to periodically check for when those interrupts
           are free for use.  Or, you can use the cheater way (which is
           used by DOS itself):  Whenever DOS is waiting for a keypress,
           it calls int 28h (undocumented).  The only program I know of
           "legally" using this is the PRINT command.  Whenever int 28h
           is called, you should be free to do whatever you want.  If you
           want more immediate access to the disk, though, you'll need to
           use the timer int (1Ch) again.  ONCE, at initialization time,
           do an int 21h ah=34h.  In ES:BX, you will have the address of
           a byte called INDOS by most folks.  This is an undocumented
           function which has been officially declared off-limits by
           Microsoft, but nobody pays attention to them anyway.  As far
           as I know, it works fine in all versions of MS-DOS as of today
           (April 1988).  In your timer interrupt servicer, read the byte
           at the address you got from service 34h.  If it's not zero,
           don't do anything over service 0ch; if it's zero, go crazy.
           What this byte is (I'm told) is a count of how many calls deep
           DOS is into itself.  The actual value is of no relevance to
           us, just if it is zero or not.  Now, I don't see this helping
           much if the program is doing BIOS I/O, but I don't use any
           software I know of which uses BIOS for disk I/O.  Also, if the
           application is doing direct-to-the-hardware disk I/O, I don't
           think you probably want to be messing with this stuff.  Again,
           I don't use anything that I know of doing this.

                I've written several programs using the int 28h/service 34h combo
        to do TSR disk I/O and have never had a single problem, and I
           tested them in the middle of all kinds of disk accesses.  This
        does not mean it's always cool, though.  If you can help it, al-
        ways avoid undocumented stuff.  In my opinion, Microsoft won't
        change it because so much software relies on it now, but I've
        learned not to trust them.

                  o Example program complete with flimsy excuses

                The Sperry PC has a high-res graphics screen which is treated as a
        logically different display from the normal text screen, and uses
        different display memory banks.  The text bank, called screen A,
        can be superimposed over the graphics (called screen B) on the
        screen simultaneously.  This program switches between screen A on-
        ly, screen B only, and screen A superimposed on screen B.  This
        program is for example only, and you should not attempt to run it
        on a CGA.  If something gets fried, it's not my fault.  It looks
        for a keypress of Alt-Esc, goes into action, and then quits.


                I hope this has been helped you understand how a basic keyboard
        driven TSR works.  If you have any more questions, feel free to
        contact me with them, and I will find you an answer.  Most ad-
        vanced TSR functions (almost all are undocumented by Microsoft and

        ;page 10
        

        IBM!) have been discussed in Byte, PC Tech Journal, and Dr.
        Dobb's Journal, but have been thoroughly discussed in Programmer's
        Journal.  I highly recommend this publication, and hope more
        people will subscribe, so it does not fold up and deprive me of
        all the information it provides.


        Call the Telstar BBS:  (512)822-8882 for a good time




        Garrett P.  Nievin  has also contributed a piece of code to service a
        soft breakout switch for Symdeb and Debug. Please see the listing in
        the source code section. Both of these are extremely well commented
        and should be quite useful.










































;page 11



                              Hex Conversion Routines

                Just a little "quicky" to fill out this issue. These are a
        couple of routines that I use regularly in a variety of ways. They are
        both fast and fairly tightly coded and they work. I hope you find them
        of some use.

                The first, DECHEX, takes an ASCII number pointed to by SI and
        returns a hex number in AX. The other just reverses the process, and
        when used with the little MOV_ASCII puts it where you tell it to.

;~
 DECHEX:                         ;THIS ROUTINE WILL TAKE A [CL] (MAX 5) DIGIT
                                ;ASCII DECIMAL NUMBER POINTED TO BY SI AND
                                ;RETURN A 4 DIGIT HEX NUMBER IN AX.*
                XOR     DH,DH
                XOR     AX,AX
TRY:            CMP     CL,1
                JBE     LASTA
                MOV     DL,[SI]
                SUB     DL,"0"
                ADD     AX,DX
                MOV     BX,AX
                SHL     AX,1
                SHL     AX,1
                SHL     AX,1
                ADD     AX,BX
                ADD     AX,BX
                INC     SI
                LOOP    TRY
LASTA:           MOV     DL,[SI]
                SUB     DX,"0"
                ADD     AX,DX
                RET


HEXDEC:         ;THIS ROUTINE WILL TAKE A 4DIGIT HEXADECIMAL NUMBER IN AX AND
                ;RETURNS A 5 DIGIT ASCII IN BH,BL,DH,DL,AL.
                ;TIME AVERAGES ABOUT 140 CLOCKS PER DIGIT
                ;LEADING 0'S ARE SUPRESSED
                MOV     BX,0
                MOV     CX,0
                MOV     DX,0
A10K:           CMP     AX,10000
                JB      A1K
                SUB     AX,10000
                INC     BH
                JMP     A10K
A1K:            CMP     AX,1000
                JB      HUNDREDS
                SUB     AX,1000
                INC     BL
                JMP     A1K
HUNDREDS:       CMP     AX,100
                JB      TENS
                SUB     AX,100
                INC     DH
                JMP     HUNDREDS
;page 12


TENS:           CMP     AX,10
                JB      UNITS
                SUB     AX,10
                INC     DL
                JMP     TENS
UNITS:
                MOV     AH,'0'
                ADD     BH,AH
                ADD     BL,AH
                ADD     DH,AH
                ADD     DL,AH
                ADD     AL,AH
                CMP     BH,AH
                JNZ     UEND
                MOV     BH,020H
U1:
                CMP     BL,AH
                JNZ     UEND
                CMP     BH,020H
                JNZ     UEND
                MOV     BL,020H
                CMP     DH,AH
                JNZ     UEND
                CMP     BL,020
                JNZ     UEND
                MOV     DH,020H
                CMP     DL,AH
                JNZ     UEND
                CMP     DH,020
                JNZ     UEND
                MOV     DL,020H
UEND:
                RET

MOV_ASCII:                              ;THIS TAKES THE DIGITS PRODUCED BY
                                        ;HEXDEC AND PUTS THEM AT DS:SI
                MOV     [SI],BH
                INC     SI
                MOV     [SI],BL
                INC     SI
                MOV     [SI],DH
                INC     SI
                MOV     [SI],DL
                INC     SI
                MOV     [SI],AL
                RET
;~











;page 13


                          Book Reviews

        The Programmers' Reference

                I made a quick review of this last month, but I have since
        gone over it thoroughly and received the extended package from the
        author.  This is NOT an instruction book for beginners.  It is
        just what it names itself- a reference manual.
                The shareware version is 10 chapters (about 600k bytes) of
        solid information and a table of contents. Much of the information
        is very difficult to find elsewhere. The first chapter is a quick
        history of DOS from 1.0 to 4.0. Chapter 2 has the Port addresses
        and the Interrupts up to 0fh.  Chapter 3 has the true Bios
        interrupts 10h to 1fh and it throws in INT 20h for some strange
        reason. This isn't just a listing that you might find in many
        places, but a detailed description with calling conventions and
        special things to watch out for. It includes semi-documented
        functions such as all of the Desqview and Topview int patches that
        go into this area. Each interrupt lists what machines it is
        included in from Tandy to PCjr to PS-2 model 80. I haven't counted
        them, but there must be thousands.
                The DOS interrupts 20h through 4fh are covered in similar
        detail, with many notes and application information.
                Further chapters contain information on file structures,
        EMS memory, and many other topics.
                The registered version gives another disk full of
        miscellaneous data that is rare and useful.
                The $15 price is one of the greatest bargains to be found.
        Available on many BBS's as ####ref.??? such as 1029ref.zip. This
        says that it is the October 29th release, and the extension is up
        to the Sysop.



























;page 14


                        Source Code for Keyboard TSR


; High Res screen A/B toggler for Sperry PC, the best PC around
; Written for MASM 4.0
code    segment para public 'code'
        assume cs:code,ds:code,es:code
        org     0100h           ; .COM format
start   proc    far

; Equates - ports, locations, values
; Using equates makes the program much easier to change later;
; to use a different scancode here, for example, you would just
; change the equate for "esc".
         if1                    ; only assemble equates on pass 1
portB    equ    61h             ; 8259 port B - used to clear scancode 
keyport  equ    60h             ; 8259 port A - keyboard scan codes
esc      equ    01h             ; scan code for Escape key
hibiton  equ    80h             ; hi bit on for keybreak scan code & reset
hibitof  equ    7fh             ; hi bit off for keybd reset
DOS_area equ    40h             ; segment of BIOS/DOS data area
shftstat equ    17h             ; keybd shft status flag in DOS area
shift    equ    00000011b       ; value for shftstat meaning either shift is on
eoi      equ    20h             ; end of interrupt flag
comdport equ    20h             ; 8259 command port
         endif

begcode:
        jmp     implant         ; jump around interrupt handler code
begres:         ; area to remain core resident

rescode proc                    ; keystroke causes jump to resident code here

        jmp     oversign        ; jump over memory signature
        db      'abGN'          ; program signature in memory
; I use my initials in uppercase and a 2-byte program ID in lowercase

; Variables

mode    db      0               ; superimpose mode: 0-A,1-B,2-Both,3-None
oldint9 dw      0,0             ; doubleword value of old int9 vector

oversign:       ; start of code for new interrupt 09h handler

        push    ax              ; save that register
        push    ds              ; save DS.
        mov     ax,DOS_area     ; DOS data segment
        mov     ds,ax           ;   now covered by DS
        test    byte ptr ds:[shftstat],shift ; is a shift being held now?
        jz      normal          ; nope, not a hot key, pass it on to old int
        in      al,keyport      ; yes, get keyboard scan code
        cmp     al,esc+hibiton  ; was it release of escape?
        je      abnorm          ; yes, lose that scan code
        cmp     al,esc          ; was it an escape?
        jne     normal          ; nope, skip the important stuff
;
        mov     al,mode         ; get mode
        cmp     al,2h           ; both screens on?

;page 15


        je      aonly           ; yes, go back to first
        add     al,1h           ; add 1 to hi nybble to go  B to A to AB
        jmp     nextmode        ; and go put it back
aonly:                  ; start back with screen A only
        xor     al,al           ; turn off
nextmode:               ; put in new mode and quit
        mov     mode,al         ; move in new mode
        mov     ah,15h          ; set superimpose mode function of int 10h
        int     10h             ; and go change mode
        jmp     abnorm          ; lose scan code
;

abnorm:         ; abnormal handling of scan code.  to the bit bucket with it.
        in      al,portB        ; get portB
        or      al,hibiton      ; set acknowledge / clear keyboard bit
        out     portB,al        ; and out it again
        and     al,hibitof      ; clear ack bit
        out     portB,al        ; out that, enabling keyboard again
        cli                     ; no interruptions please, Mrs. a-Whiggins
        mov     al,eoi          ; end-of-interrupt command
        out     comdport,al     ; send it to the 8259
        pop     ds              ; restore
        pop     ax              ;   registers
        sti                     ; interruptable again
        iret                    ; quit without performing normal interrupt

normal:         ; not hot key, pass scan code on to normal (maybe) int9
        pop     ds              ; restore all
        pop     ax              ;   registers I messed with
        jmp     dword ptr cs:oldint9    ; goto old int9 handler


; all code from here out is based on Norton's guide, and I use it in
; all my TSR's.

reslen  equ     endres - begres         ; length of new resident code
strtres equ     begres - begcode + 100h ; start of resident code
psplen  equ     5ch                     ; length of necessary PSP

implant:        ; code to put new int 9 front end in core
        mov     ax,3509h        ; get int vector function
        int     21h             ; get vector of interrupt 9 handler
        cmp     es:[bx+3],'ba'  ; am I already loaded?
        jne     fresh           ; nope, go install
        cmp     es:[bx+5],'NG'  ; make sure I'm not already in
        jne     fresh           ; naaah, go install
        lea     dx,cs:stalemsg  ; DX points to already installed message
        mov     ah,09h          ; DOS display string func       
        int     21h             ; go display message
        int     20h             ; and quit
        
fresh:
        lea     dx,cs:instlmsg  ; DX points to installation message 
        mov     ah,09h          ; display string function
        int     21h             ; give the user the poop
        mov     ax,3509h        ; get int vector function
        int     21h             ; get vector of old interrupt 9 handler
        mov     oldint9,bx      ; int location in ES:BX, save it
;page 16


        mov     oldint9+2,es    ; "
        mov     ax,2509h        ; set new interrupt 9 vector to me
        mov     dx,offset rescode       ; address of which is in DX
        int     21h             ; go do it
        push    cs              ; DS and ES both end
        pop     es              ; up pointing at
        push    cs              ; code area
        pop     ds              ; "
        mov     di,psplen       ; where program will end up
        mov     si,strtres      ; start of resident code
        mov     cx,reslen       ; amount of resident code to move
        cld                     ; go forward in move
        rep movsb               ; move code back in mem
        mov     dx,psplen + reslen      ; DX pointing to next free paragraph
        mov     ax,3100h        ; keep, return code of 0
        int     21h             ; terminate

stalemsg db     'Screen A/B toggle is already installed and active!',13,10,7,7
instlmsg db      'High Res Screen A/B toggle',13,10
        db      'Shift/Escape toggles screen A only, then B only, then A/B.'
        db      13,10,'$'
                
start   endp
code    ends
        end     start































;page 17


                             Source for Soft Breakout


; BUGOUT.COM
; Program to add wimpy "soft" breakout key to DEBUG and SYMDEB
;
; MASM compatible source code
;
; Hitting the '5' on keypad forces an int 3 (debug breakpoint)
; After breakpoint, add 1 to IP register and trace through IRET
;
; By Garrett P. Nievin
;
; (BTW, to add a hardware breakout switch just put a switch between
; pins 17 (NMI) and 40 (+5V) on your 8088 chip, and a switch between
; pins 21 (RESET) and 40 will do a system reset/reboot.)


code    segment para public 'code'
        assume cs:code,ds:nothing,es:nothing
        org     0100h

hotkey  equ     4ch         ; scan code for hot key = "5" on keypad
portA   equ     60h         ; 8255A port A, usually keybd scan code
portB   equ     61h         ; 8255A port B, various switches
release equ     80h         ; hi bit in scan code means key release
hibiton equ     80h         ; hi bit in byte for or'ing in
hbitoff equ     7fh         ; hi bit in byte for and'ing out

start   proc    far
begcode:
    jmp  implant            ; jump around interrupt handler code
begres:                     ; area to remain core resident
rescode  proc               ; keystroke causes jump to here
    jmp  over               ; jump over memory signature
    db  'bcGN'              ; program signature in memory
over:                       ;
    sti                     ; allow interrupts
    push ax                 ; save that register
    in   al,portA           ; get keyboard scan code
    cmp  al,hotkey          ; hotkey?
    jne  normal             ; yes, go hanlit
    push dx                 ; save register
    mov  dx,0020h           ; port 20h = PIC port to send EOI to
    mov  al,dl              ; 20h turns on EOI bit
    out  dx,al              ; tell interrupt controller we be done
    pop  dx                 ; restore register
    in   al,portB           ; get portB
    or   al,hibiton         ; set acknowledge / clear keyboard bit
    out  portB,al           ; and out it again
    and  al,hbitoff         ; clear ack bit
    out  portB,al           ; out that, enabling keyboard again
    pop  ax                 ; restore original register
    int  3                  ;
    iret                    ;

;page 18


normal:                     ;
    pop  ax                 ; restore that register
    jmp  dword ptr cs:oldint9    ; goto old int9 handler
oldint9  dw  0,0            ; doubleword value of old int9 vector
rescode  endp

endres:                     ; end of core res area

reslen  equ endres - begres           ; length of new resident code
strtres equ begres - begcode + 100h   ; start of resident code
psplen  equ 5ch                       ; length of necessary PSP

implant:                    ; code to put new int 9 front end in core
    mov  ax,3509h           ; get int vector function
    int  21h                ; get vector of interrupt 9 handler
    cmp  es:[bx+3],'cb'     ; already loaded?
    jne  fresh              ; nope, go install
    cmp  es:[bx+5],'NG'     ; make sure
    jne  fresh              ; naaah, go install
    lea  dx,cs:stalemsg     ; DX points to already installed message
    mov  ah,09h             ; DOS display string func
    int  21h                ; go display message
    mov  ax,4cffh           ; terminate with code = 0xff
    int  21h                ;
        
fresh:
    lea  dx,cs:instlmsg     ; DX points to installation message
    mov  ah,09h             ; display string function
    int  21h                ; give the user the poop
    mov  ax,3509h           ; get int vector function
    int  21h                ; get vector of old interrupt 9 handler
    mov  oldint9,bx         ; int location in ES:BX, save it
    mov  oldint9+2,es       ; "
    mov  ax,2509h           ; set new interrupt 9 vector to me
    mov  dx,offset rescode  ; address of which is in DX
    int  21h                ; go do it
    push cs                 ; DS and ES both end
    pop  es                 ; up pointing at
    push cs                 ; code area
    pop  ds                 ; "
    mov  di,psplen          ; where program will end up
    mov  si,strtres         ; start of resident code
    mov  cx,reslen          ; amount of resident code to move
    cld                     ; go forward in move
    rep  movsb              ; move code back in mem
    mov  dx,psplen + reslen ; DX pointing to next free paragraph
    mov  ax,3100h           ; keep, return code of 0
    int  21h                ; terminate
stalemsg db 'Bugout already resident.',10,13,7,'$'
instlmsg db 'Bugout loaded and active, keypad-5 is break key.',10,13,'$'
start    endp
code     ends
    end  start





;page 19

;;;;;;;;;;;;;;;;;

THE ASSEMBLY LANGUAGE "MAGAZINE"                  VOL 1 NUMBER 4
                                                  December 1989

















  ##     ####    ####   ####### ##   ## ######  ####    ##  ##
 ####   ##  ##  ##  ##   ##   # ### ###  ##  ##  ##     ##  ##
##  ##  ###     ###      ## #   #######  ##  ##  ##     ##  ##
##  ##   ###     ###     ####   #######  #####   ##      ####
######     ###     ###   ## #   ## # ##  ##  ##  ##   #   ##
##  ##  ##  ##  ##  ##   ##   # ##   ##  ##  ##  ##  ##   ##
##  ##   ####    ####   ####### ##   ## ######  #######  ####

        ####      ##    ##   ##   ####  ##  ##    ##      ####  #######
         ##      ####   ###  ##  ##  ## ##  ##   ####    ##  ##  ##   #
         ##     ##  ##  #### ## ##      ##  ##  ##  ##  ##       ## #
         ##     ##  ##  ## #### ##      ##  ##  ##  ##  ##       ####
         ##   # ######  ##  ### ##  ### ##  ##  ######  ##  ###  ## #
         ##  ## ##  ##  ##   ##  ##  ## ##  ##  ##  ##   ##  ##  ##   #
        ####### ##  ##  ##   ##   ##### ######  ##  ##    ##### #######























 Written by and for assembly language programmers.



                                 Table of Contents

          Editorial.......................................2
          Policy and Guide Lines..........................3
          Beginners' Corner...............................5
          Structure, Speed and Size
               By Thomas J. Keller........................7
               Editorial Rebuttal........................11
          Accessing the Command Line Arguments
               By Thomas J. Keller.......................13
          Original Vector Locator
               by Rick Engle.............................15
          How to call DOS from within a TSR
               by David O'Riva...........................22
          Environment Variable Processor
               by David O'Riva...........................26
          Program Reviews................................35
               Multi-Edit ver 4.00a .....................35
               SHEZ......................................36
               4DOS......................................36
          Book Reviews...................................37
               Assembly Language Quick Reference
                    Reviewed by George A. Stanislav......37
          GPFILT.ASM.....................................39



































                                   ;Page 1









                                  Editorial


          It has been much too long since the last issue of the Magazine was
     published. Much of this time was due to the lack of submissions but
     there has been enough to assemble since early November. I hope that
     it will not be as long till the next one is ready for distribution.
     You can help make that possible by writing up and sending in an
     article.

          I'm trying out a new editor for this issue.  That makes it four
     editors for 4 issues. There is a review of it in the review section.

          There is a continueing and probably insoluable problem in
     formatting the 'Magazine'.  The readability of the text portions is
     enhanced with wider margins and is more easily bound with a wide
     left margin.  The difficulty arises when source code is included. 80
     columns is little enough in which to fit the code and comments,
     allowing nothing for margins. So this time we'll try a 5 space
     margin on the left for the text portion. Further offset should
     be done with your printer.

          A couple of quick notes here as I don't know where else to put
     them.

          For the assembly programmer the principle difference in writing
     for DOS4+ is that there is a possible disk structure using 32 bit
     FAT entries.  This of course has no effect as long as you use only
     the DOS calls for disk access, but if you are going to do direct
     disk editing this must be checked for.

          The occasional   ~  is for the use of my spelling checker.





















                                      ;Page 2
     



                         Policy and Guide Lines


          The Assembly Language 'Magazine' is edited by Patrick and David
     O'Riva. We also operate the AsmLang and CFS BBS to distribute the
     'Magazine' and to make available as much information as possible to
     the assembly language programmer. On FidoNet the address is
     1:143/37. Address:
                         2726 Hostetter Rd
                         San Jose, CA 95132
                         408-259-2223

          Most Shareware mentioned is available on the AsmLang board if local
     sources cannot be found

          Name and address must be included with all articles and files.
     Executable file size and percent of assembly code (when available)
     should be included when a program is mentioned and is required from
     an author or publisher.  Any article of interest to Assembly
     language programmers will be considered for inclusion.  Quality of
     writing will not be a factor, but I reserve the right to try and
     correct spelling errors and minor mistakes in grammar, and to remove
     sections.

          Non-exclusive copyright must be given.  No monetary
     compensation will be made.

          Outlines of projects that might be undertaken jointly are
     welcome.  For example:  One person who is capable with hardware
     needs support from a user friendly programmer and a math whiz.

          Advertisements as such are not acceptable.  Authors and
     publishers wishing to contribute reviews of their own products will
     be considered and included as space and time permit.  These must
     include executable file size, percent of assembly code and time
     comparisons.

          Your editor would like information on math libraries, and
     reviews of such.

          Articles must be submitted in pclone readable format or sent
     E-mail.


          Money:  Your editor has none.  Therefore no compensation can be
     made for articles included.  Subscription fees obviously don't
     exist.  Publication costs I expect to be nil (NUL).  Small
     contributions will be accepted to support the BBS where back issues
     are available as well as files and programs mentioned in articles(if
     PD or Shareware ONLY).

          Shareware-- Many of the programs mentioned in the "Magazine"
     are Shareware. Most of the readers are prospective authors of
     programs that can be successfully marketed as Shareware.  If you
     make significant use of these programs the author is entitled to his
     registration fee or donation.  Please help Shareware to continue to


                                   ;Page 3



     be a viable marketing method for all of us by urging everyone to
     register and by helping to distribute quality programs.

























































                                   ;Page 4



                            Beginners' Corner

          I finished up the last column by saying I would discuss more
     techniques this time. I have entirely forgotten what they were. So
     without dwelling on that we will just move on the means of getting
     your program ready to run.  The two formats (.com and .exe) are very
     different and so will be discussed separately.

     COM Programs

          On Entry all of your segment registers are set to the same
     value, that of the start of the PSP. Your stack pointer is set to
     the top of the segment, and your instruction pointer is set to 100h.
     You need to make a generous estimate of the maximum amount of stack
     that your program can use (or count it exactly)  Each level of Call
     uses 2 bytes (for the address of the next instruction). An INT uses
     6 bytes. (2 for the IP, 2 for the CS, and 2 for the Flags). Each push
     of course uses 2. So if your subroutines can go 4 levels deep and
     contain 7 pushes (without intervening pops) and the deepest contains
     an INT21h, then you would need at least 28 bytes of stack.  But
     stack space is cheap, and you might need to change things. So use a
     nice round number of 128 bytes. BIOS also uses YOUR stack in the
     earlier versions of DOS, and the guideline for that is at least 128
     bytes. Result: 256 bytes is safe for a modest program. To implement
     this the following lines of code could be used at the start of the
     program:                                                           ~
               org            100h
                              jmp main
               defstack       db   32 dup('stack   ')
               stacktop       label     byte

               ;other data

               main:
                              cli
                              mov       sp,offset stacktop
                              sti
                                                                         ~

          The db statement is 32 times the string of 8 characters
     totaling 256 bytes. It could just all well be db   256, but it is
     kind of nice when looking at it with a debugger to see the stack
     area and how much has been used all nicely labeled.  The  cli and
     sti aren't really necessary here because it is only one instruction,
     but you are dealing with the stack, and it's well to remember that.

          At the end of your program you need a label e.g.
     ~
               progend        label     byte

          Then following your stack adjustment above:

                              mov       bx,offset progend
                              mov       cl,4
                              shr       bx,cl
                              inc       bx
     ~


                                   ;Page 5



          These instructions change the offset value into a number of
     paragraphs (16 bytes) and to the end of the last paragraph. This is
     the total number of paragraphs that will be occupied by your
     program. Then it is necessary to inform DOS of this information:
     ~
                              mov       ah,4ah
                              int       21h
     ~
          4a is the DOS function to modify allocated memory. It needs the
     new number of paragraphs in BX (which is where it was put)

          At this point, your program is in an orderly condition. Your
     data as well as that in the PSP is available with the DS and ES
     registers, The stack is large enough and well mannered, and all
     surplus memory is available to you or other programs.












































                                   ;Page 6





                        Structure, Speed and Size
                                     as
                        Elements of Programming Style

                             By Thomas J. Keller
                               P.O. Box 14069
                            Santa Rosa, CA, 95402


          Let us examine the reasons for choosing to implement a given
     program in assembly language as opposed to some high level language.
     The reasons most commonly given are execution speed and memory image
     size.

          Execution speed, except in certain highly critical realtime
     applications, or certain high resolution graphics applications, is
     probably not a realistic reason to opt for assembly language.  For
     example, a good C compiler with optimization (which precludes use of
     Turbo or Quick C) produces code which only suffers a 10-15% speed
     penalty, over typical hand crafted assembly language code.  It is
     possible to write assembly language code which will run faster than
     this, but few programmers have the requisite skills.

          In most applications, a 10-15% speed penalty is simply
     irrelevant.  It is unlikely that the typical user would even notice
     such a difference.   In particular, programs which are highly
     interactive, and thus spend far and away the greatest amount of time
     waiting for user input are highly insensitive to such speed
     penalties.  Many people don't realize that even assuming that the
     user is typing at a rate of 100 wpm (approximately 500
     keystrokes/minute), the CPU is still spending the bulk of its time
     idling, waiting for the next keystroke.

          There are, of course, always exceptions to virtually any rule,
     and there are most certainly exceptions to this rule.  Word
     processors, for example, while actually accepting text input, are
     not speed critical.  When performing global search and replace, or
     spell checking, for example, even a 10% penalty can become expensive
     on large documents.  So there is a tradeoff to be made.

          Assembly language programs cost considerably more than 10-15%
     more to develop than high level programs.  The minutiae involved in
     managing a massive assembly language programming effort are
     overwhelming.  Assembly language programs take MUCH longer to
     complete, in almost all cases, than high level programs do, a major
     contributory factor in the overall cost of development.  Finally,
     projects developed in high level programming languages are much more
     likely to be easily ported to platforms based on processors other
     than the platform on which the project is developed, and very
     important consideration for a major project.  The ability to port a
     project easily to other platforms increases the market for a
     product, thereby not only increasing the profitability of the
     product, but also helping to reduce the sale price of the product
     (larger market generally translates to lower per unit cost).



                                   ;Page 7



     So the vendor or developer must analyze the relative impact of a
     small improvement in execution speed vs a large increase in
     development time and cost, which consequently translates to higher
     selling prices, thereby reducing the anticipated market for their
     product.  In many cases, the tradeoffs do not merit choosing
     assembly language.

     Let us turn now to binary image size (memory size).  The
     advantages of small programs are clear, when examining programs
     which are, in the DOS world, TSRs (The MAC and AMIGA worlds have
     similar cases, though I am not sufficiently familiar with them to
     know what they are called).  These programs are loaded into memory,
     and remain there until explicitly removed, which means that the
     memory they use is NOT available for other uses.  Device drivers
     similarly use memory, precluding its use for other programs, and
     therefore also clearly benefit from small size.   In the
     multi-tasking world (DeskView or PC/MOS, in the PC clone market),
     small executables also have an advantage, permitting more programs
     to be run "simultaneously" in a given memory configuration, though
     running multi-taskers in severely restricted memory configurations
     probably qualifies as a technical error.

     What of normal, single tasking, single user environments (such as
     DOS, the MAC and AMIGA environments)?  Besides the ego boost of
     creating a very small, very tight utility or application, what benefit
     is there in generating very small programs?

     They take less disk space to store, but realistically, at least
     under DOS, lots of very small utilities may actually not achieve a
     significant savings in disk space, due to granularity of storage
     allocation.  They load a little faster, in most cases.

     But once again, the economics of the issue comes back to haunt us.
     It is not clear that the effort and expense of writing most
     applications in assembly language due to size considerations is an
     economically rational decision.  The same economic pressures and
     considerations apply as do to the execution speed issue discussed
     above.

     On to structure.  I must take issue with Patrick O'Riva regarding
     their purpose and nature of "structured programming."  While much of
     his definition is true, it is incomplete, and appears to reflect a
     misunderstanding of certain aspects of the structured approach to
     programming.

     Firstly, it is entirely possible (and not altogether a rare
     occurrence) to write thoroughly unstructured code in PASCAL or C.  One
     must take care to recognize the difference between references to a
     "block structured" language, as PASCAL and C both are, and "structured
     programming," which is really a totally separate issue.

     Structured programming is an approach to programming that is
     thoroughly applicable to whatever language a project is being
     implemented in.  It implies firstly a step-wise refinement approach
     to defining the solution to a problem which the program is to address
     (in other words, determining the nature of the desired goal, and an
     at least rational approach to reaching said goal).  Secondly, it


                                   ;Page 8



     involves determining, to the extent possible, the nature and structure
     of the data that is to be processed by the program.  Finally, it
     involves a top-down approach to the actual coding process.

     Just what is a top-down approach?  Essentially, this means that we
     code the high level functionality of the program first, programming
     simple "do nothing" stubs for the lower levels of the program.  As
     necessary to test the high level code, we implement lower level
     functions, again, if needed, programming still lower level stubs.
     Assuming that the structured design approach of step-wise refinement
     was used to begin with, the actual coding should really amount to
     translating the logic flow diagrams, or pseudo-code, or whatever means
     of recording the refinement process was used, into actual program
     code.  In the ideal situation, the program almost literally codes
     itself at this point.

     There is a myth that "structured programming" means "goto-less"
     programming.  In fact, this is not the case.  This myth came into
     being through misunderstanding of the rather harsh criticism of the
     "go to" which occurred in the computer science journals beginning in
     approximate the mid to late sixties.  This criticism was based
     primarily upon the typically excessive use of the "go to" in FORTRAN
     and BASIC programming at the time.  Such indiscriminate use of "goto"
     led to what has been called "spaghetti" code, code which is virtually
     impossible to trace or analyze.

     In fact, there are many cases in programming where the goto is most
     structured solution available.  Structured coding techniques are
     intended to clarify and make easier the process of analysis, design
     and implementation of computer programs, not to define rigid, strictly
     enforced rules in the face of all reason.

     Structured programming is ALWAYS the best approach to ANY computer
     program.  If the internal requirements of the program, as regards
     speed or memory utilization, dictate the use of goto's, then use them.
     A properly documented GOTO can be far more "structured" than an
     undocumented string of modular function calls.

     So, back to assembly language programming.  When is it appropriate
     to choose assembly language to implement a program?  First, and most
     obviously, when the speed or memory utilization requirements of the
     application demand the capabilities that well crafted assembly
     language offers.  Second, perhaps not so obviously, when it is
     necessary to work at the hardware level a great deal.  High level
     languages, even C, do not generally manipulate hardware registers
     efficiently.  So, if your program makes frequent or widespread use of
     direct hardware manipulation, it is a likely candidate for assembly
     language.

     Finally, and probably the most gratifying reason of all to choose
     assembly language, is when you want the satisfaction of having tackled
     a project in assembly and pushed the bits around to suit your purpose.
     There is little I can imagine that is more satisfying than to reach
     down into the microprocessor chip and twiddle those bits.  Just be
     sure that you don't let your ego cloud your judgment, when the
     economics of the project are important (e.g., when a project is to be
     distributed commercially, or there is an urgent need for speedy


                                   ;Page 9



     completion).

     I believe that all PROGRAMMERS (as opposed to casual computer
     users) should learn the assembly language for the machines on which
     they work.  Besides offering the flexibility of shifting to assembly
     to meet a specific goal, learning assembly intimately familiarizes the
     programmer with the hardware on which s/he is working.  The more you
     know about your hardware environment, the better off you are.



















































                                   ;Page 10



                             Editorial Rebuttal

          I thank Mr. Keller very much for his article and agree with
     many of the points he has made.  However I must still argue the
     points of size and speed and justification.

          Whenever a program is user limited and will not be used in a
     multi-tasking environment as is often the case with a word processor
     and certain drawing programs, there may be little to be gained in
     assembly programming. Also there are programs which are DOS limited
     and little speed increase is possible.

          Mr. Keller uses a figure of 10 to 15 percent speed penalty. My
     experience indicates a value closer to 300 to 400 percent though
     direct comparisons are difficult to make because the same programs
     are usually not written in both assembly and in C. The size
     difference seems to be a factor of 5 to 10.  The two prime examples
     I can offer are both by Microsoft, and it can be assumed they make
     use of an optimizing compiler. Their assembler is approximately 110k
     in size. A86 while not compatible in syntax has comparable features.
     It's size is 22k and assembles code in about one eighth the time.

          Microsoft's programmers' editor is vaguely 250k.  Qedit is
     about 50k and is a mix of high level and assembly. You can grow gray
     hairs waiting for the MS editor to do a search and replace, but if
     you blink you'll miss it with Qedit. A fully capable full screen
     editor without the extras that make it a pleasure to use can easily
     be written in less that 5k. Give another 5k for features. What has
     MS gained with the extra 240k of code?

          David has recently completed (though they are still adding
     modules) a database and accounting program for a multi-office
     company. A much abbreviated version was threatening to overflow their
     384k limit. Investigation of a Dbase implementation indicated in
     excess of 500k. Data base sorts used to take 10 hours. They now take
     20 minutes. Savings in processing time and entry time plus increased
     functionality suggest a savings of $5000 to $10,000 per month PER
     OFFICE. Code size? 35k. Are they unhappy about the $15,000 they've
     been charged for a program that will get lost in a single floppy
     disk?

          Given the above examples, I must maintain that the use of high
     level language, when there is significant processing to be done, and
     when it will be used on a regular and continuing basis, benefits
     only the software corporation, and is detrimental to the end user.

          On Structured Programming I fully agree with Mr. Keller and
     hope that he clarified any misconceptions I left you with. I prefer
     a bottom up construction, but that is only preference and has no
     effect on the end product.

          Dave's notes:  Mr. Keller mentions that it is possible to get
     great size/speed reductions, but that few programmers have the requisite
     skills.  But to a large extent, it isn't the skill that makes the
     program, it's the toolbox.  The C language is extremely close to
     assembly - MSC does a very good job of optimizing - and it takes care of
     the minutiae for you.  The problem with this is that the libraries


                                   ;Page 11



     supplied with the compilers were written to handle very general cases.
     The printf() function is an extreme example, but it typifies the
     problem:  If you use printf once in your program to print "Hello", it
     adds 30K of code!

          Another concern is that many high-level-language programmers
     don't even realize that with a tweak here, using putc instead
     of printf there, they can get much(!) better performance from their
     programs.  Familiarity with the quirks of the compiler being used is a
     necessity... And even that isn't enough to get good performance out of a
     large program.  AND, it decreases portability.  So you're right back
     into the twiddling usually associated only with assembly.

          I've found that if I use C for anything except flow control and
     one-shot tools, my programs start to get huge and slow, relative to
     anything that I've banged out in assembly.  The database is a great
     example - it's a very complicated application, with a completely
     separated data engine & OS interface.  If it had been written in C, it
     would be working in multiple code segments on a 286 with 4 megs and
     STILL take hours to run a balance, instead of 35K of code on an XT
     network terminal with half-hour runs.

          The database was indeed a massive effort, but at this point it
     would be possible to strip out the engine and write with ease (and
     macros - lots of macros) anything that could be done in C or Dbase, and
     do it much better.  And average runtime is cut at least in half, size by
     50-90%.  With a reasonably solid and application-specific toolbox, the
     advantages TO THE CUSTOMER of assembly programming completely eclipse
     those of any other language and the disadvantages of assembly itself.

          Portability is another issue entirely.  If you NEED
     portability and fast development, and IF run time and general
     productivity are not a concern, then C probably makes more sense.
     There's this nagging feeling, though, that if the UNIX OS core had been
     written in assembly by a reasonably good programmer, and been ported to
     new systems in kind, that the university systems would be clipping
     instead of slogging.

          As far as structured programming goes, I usually design as I go
     along, and end up with a functional (even rational) structure.  Call it
     "random-access programming."  This is probably because I find it
     difficult to call a routine until I've laid out the calling conventions
     for it, and while I'm doing that I'll remember another routine that
     should be written for another module...  This is not the generally
     recommended method, I gather.














                                   ;Page 12



               Accessing the Command Line Arguments
                        in Assembly Language Programs

                            By Thomas J. Keller
                               P.O. Box 14069
                            Santa Rosa, CA, 95402


          If you're like me, you program in several languages, under
     several different operating systems.  Under DOS, one very useful
     feature is the capability to pass arguments to a program as part of
     the invocation command line.  The use of command line arguments
     significantly increases the power and flexibility of your programs,
     as well as improving the "professional look."  Many languages
     support this capability with intrinsic or library routines which
     facilitate access to these command line arguments.  Assembly
     language, of course, does not.  What is a programmer to do?

          As it turns out, it is quite simple to access the command line
     arguments under DOS.  DOS places the so-called "command tail" (the
     command line less the actual program name) into a buffer area
     reserved in the PSP (Program Segment Prefix).  This buffer area is
     known as the DTA (Disk Transfer Area).

          It is extremely important that you parse the command tail, if you
     plan to do so at all, immediately upon entering your program.  DOS
     does some particularly obscure and insidious things with this DTA
     buffer, which will destroy the command tail information.

          In a .COM format program, the PSP is the first 100h (256) bytes
     of the program memory image, making access quite straightforward.
     How do we locate the PSP in a .EXE format program, however?

          Fortunately, DOS sets the ES segment register to point to the
     beginning of the PSP under both .COM and .EXE programs.  It happens
     to be the case that DOS also sets all other segment registers to the
     same location for a .COM program, simply because .COM programs
     reside in one and only one segment.  In an .EXE invocation, the DS
     and ES registers are set to point to the segment in which the PSP
     resides as the first 100h bytes.  This is the default data segment
     as well.

          The DTA begins at offset 80h (128d) from the beginning of the
     PSP.  When it contains a command tail, the byte at 80h contains the
     count of the number of bytes actually in the command tail, and the
     command tail string begins at offset 81h (129d) from the beginning
     of the PSP.  The first byte of this string is always a blank (20h),
     and the string is terminated with a  (0dh).

          The exact means you use to parse the command line arguments is,
     of course, up to you.  One possible approach is as follows:
          1) Use the data definition directives to set aside any memory you
          will need to store information about command line arguments
          (e.g., buffers for file names, byte or word values for flags and
          numeric arguments, etc.).

          2) Design a routine that starts scanning the command tail string for


                                     ;Page 13
     


          arguments.  a 'first fit' (the shortest match possible) scheme is
          easiest to program.  As each item is located and identified as to
          type and purpose, store the appropriate information in the data
          areas you have already set aside.
          3) Have a "usage" message defined, and a small routine to print it
          to the screen (a good idea is to print it to STDERR).  Invoke
          this routine when the first argument on the command line is a
          '?,' or, if the program requires arguments, when it is invoked
          without them.
          4) You now have the switches, filenames, and other command line
          arguments available.  Write your program to use them
          appropriately.

          Included in this issue of Assembly Language Magazine is an source
     listing which is a sample template GPFILT.ASM for a general purpose
     assembly language filter.  This program provides an excellent sample
     of command line argument parsing and one way of using these
     arguments (though the method used here is not the same as the one
     described above).








































                                     ;Page 14
     


                         Original Vector Locator
                              by Rick Engle

                               November, 1989

     INTTEST is a small assembly program which attempts to find the
     original address of the INT 21h function handler.  This is valuable
     if you need to be able to make calls to the original INT 21h
     function even if a TSR or other program has that interrupt hooked or
     trapped.  This gives your program secure control over the interrupt
     regardless of who is using it.

          I did this prototype in an attempt to make certain programs
     somewhat immune to the effects of destructive viruses that may
     intercept INT 21h and use it for their own use.  This technique
     could be used to find the original address of other MS-DOS
     interrupts.  I wrote test programs to dump out the address of MS-DOS
     interrupts (such as INT 21h) and then disassembled portions of
     MS-DOS at those addresses to identify a stable signature of the
     interrupt.  Then by following the chain to MS-DOS through the PSP
     (Program Segment Prefix) at offset 5h, I was able to find the
     segment:offset of the address of the handler for old CP/M calls.

          This pointed to the correct segment in memory of MS-DOS and
     from there, after moving my offset backwards about 100h in memory, I
     scanned for my interrupt signature.  Once I got a hit, I calculated
     the address of the interrupt and then could make calls to INT 21h at
     the segment:offset found.  This program is a "brute-force" method of
     finding the original address.  If anyone finds or has a better way,
     I'd be very interested in hearing about it.

          NOTE:     I have tested this program successfully on MS-DOS
          2.11, 3.20, and 3.30.
     ~
; -----------------------------------------------------------------------
;           INTTEST.ASM                       November, 1989 Rick Engle
;
;           Finds the address of the INT 21h function dispatcher to
;          allow the user to make INT 21h calls to the original
;          interrupt regardless of who or what has INT 21h hooked.
;
; -----------------------------------------------------------------------
;
print           macro   print_parm
                push    ax
                push    dx
                mov     ah,9
                mov     dx,offset print_parm
                int     21h
                pop     dx
                pop     ax
                endm

; -----------------------------------------------------------------------
; - Start of program                                                    -
; -----------------------------------------------------------------------



                                   ;Page 15



cseg            segment para public 'code'
                assume  cs:cseg,ds:cseg

                org     100h

int_test        proc    far

                print   reboot_first

                print   int_address
                mov     cl,21h
                mov     ah,35h          ; get interupt vector
                mov     al,cl           ; for interupt in cl
                int     21h             ; do it

                mov     ax,es                   ; lets display the es
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   colon

                mov     ax,bx                   ; lets display the bx
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   crlf

                print   display_header2

                mov     ah,byte ptr cs:[05h]    ; Get info from the PSP
                mov     al,byte ptr cs:[06h]    ;
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   dash

                mov     ah,byte ptr cs:[07h]    ;
                mov     al,byte ptr cs:[08h]    ;
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   dash
                mov     ah,byte ptr cs:[09h]    ;
                mov     al,byte ptr cs:[0ah]    ;
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   crlf

                print   display_header

                mov     ah,byte ptr cs:[50h]    ; Addess if INT 21 op code
                mov     al,byte ptr cs:[51h]    ; in the PSP


                                   ;Page 16



                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   dash

                mov     ah,byte ptr cs:[52h]    ;
                mov     al,byte ptr cs:[53h]    ;
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   dash
                mov     ah,byte ptr cs:[54h]    ;
                mov     al,byte ptr cs:[55h]    ;
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   crlf

                print   far_address
                mov     ax,word ptr cs:[08h]    ;
                mov     segm,ax
                push    cs                      ; set es = cs
                pop     es                      ;
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   colon

                mov     ax,word ptr cs:[06h]    ;
                mov     off,ax
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   crlf

                mov     ax,segm
                mov     es,ax
                mov     di,off
                inc     di

                print   function_jmp
                mov     ax,word ptr es:[di+2]   ;
                mov     segm2,ax
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   colon

                mov     ax,segm
                mov     es,ax
                mov     di,off


                                   ;Page 17



                inc     di
                mov     ax,word ptr es:[di]     ;
                mov     off,ax                  ; save found offset of int 21h
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   crlf

;-----------------------------------------------------------------
;si = string di = string size es:bx = pointer to buffer to search
;ax = number of bytes in buffer to search. Zero flag set if found
;-----------------------------------------------------------------

                mov     ax,segm2
                mov     es,ax                   ;segment
                mov     bx,off                  ;offset
                sub     bx,0100h                ;backup a bit to catch DOS
                mov     si,offset dos_sig       ;start at modified byte
                mov     di,dos_sig_len          ;enough of a match
                mov     ax,0300h                ;# of bytes to search
                call    search                  ;use our search
                jnz     sig_not_found           ;didn't find int 21h signature
                mov     START_SEGMENT,es        ;set page
                mov     START_OFFSET,ax         ;address of found string

                print   good_address
                mov     ax,START_SEGMENT        ;
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   colon

                mov     ax,START_OFFSET         ;
                mov     off,ax                  ; save found offset of int 21h
                push    cs                      ; set es = cs so that
                pop     es                      ; the stosb works
                mov     di,offset out_byte
                call    conv_word
                print   out_byte
                print   crlf

                push    cs                      ; set es = cs
                pop     es
                mov     bx,START_OFFSET
                mov     ax,START_SEGMENT
                mov     word ptr [OLDINT21],  bx
                mov     word ptr [OLDINT21+2],ax

                mov     dx,offset test_message
                mov     ah,9
                call    dos_function
                jmp     terminate
sig_not_found:


                                   ;Page 18



                print   no_int21_found
terminate:      mov     ax,4c00h        ; terminate process
                int     21h             ; and return to DOS

out_byte        db      'XXXX'
                db      '$'
colon           db      ':$'
dash            db      '-$'
crlf            db      10,13,'$'
reboot_first    db      13,10,'INTTEST 1.0',13,10
                db      'Reboot before running this, or',13,10
                db      'make sure INT 21h is not hooked',13,10,13,10,'$'
display_header  db      'HEX data at PSP address 50h is : $'
display_header2 db      'HEX data at PSP address 05h is : $'
int_address     db      'Original INT 21h address is    : $'
function_jmp    db      'Jump address at DOS dispatcher : $'
far_address     db      'Far address of DOS dispatcher  : $'
good_address    db      'Good INT 21h address found at  : $'
test_message    db      13,10,10,'This message is being printed using the INT '
                db      '21h Interrupt',13,10
                db      'Found by Brute Force!!!!',13,10,10,'$'
no_int21_found  db      13,10,'Int 21h address not found!$'
segm            dw      0
segm2           dw      0
off             dw      0
START_OFFSET    dw      0                       ;top addr shown on screen
START_SEGMENT   dw      0
;dos_sig         db      08Ah, 0E1h, 0EBh        ;  mov  ah,cl
;                                                ;  jmp  short  label
dos_sig         db      080h, 0FCh, 0F8h        ;  cmp  ah,0F8h
dos_sig_len     equ $ - dos_sig
OLDINT21        dd      ?                    ; Old DOS function interrupt vector

int_test          endp

; -----------------------------------------------------------------------
; -                                                                     -
; - Subroutine to convert a word or byte to hex ASCII                   -
; -                                                                     -
; -   call with AX = binary value                                       -
; -             DI = address to store string                            -
; -                                                                     -
; -----------------------------------------------------------------------

conv_word       proc    near

                push    ax
                mov     al,ah
                call    conv_byte       ; convert upper byte
                pop     ax
                call    conv_byte       ; convert lower byte
                ret                     ; and return
conv_word       endp

conv_byte       proc    near

                push    cx              ; save cx


                                   ;Page 19



                sub     ah,ah           ; clear upper byte
                mov     cl,16
                div     cl              ; divide binary data by 16
                call    conv_ascii      ; the quotient becomes the
                stosb                   ; ASCII character
                mov     al,ah
                call    conv_ascii      ; the remainder becomes the
                stosb                   ; second ASCII character
                pop     cx              ; restore cx
                ret
conv_byte       endp

conv_ascii      proc    near            ; convert value 0-0Fh in al
                add     al,'0'          ; into a "hex ascii" character
                cmp     al,'9'
                jle     conv_ascii_2    ; jump if in range 0-9
                add     al,'A'-'9'-1    ; offset it to range A-F
conv_ascii_2:   ret                     ; return ASCII character in al
conv_ascii      endp

;-----------------------------------------------------------------------
; This routine does a dos function by calling the old interrupt vector
;-----------------------------------------------------------------------
                assume  ds:nothing, es:nothing
dos_function    proc

;               mov     cl,ah           ;move our function # into cl
                pushf                   ;These instructions simulate
                                        ;an interrupt
                cli                     ;turn off interrupts
                call    CS:OLDINT21     ;Do the DOS function
                sti                     ;enable interrupts

                push    cs
                pop     ds
                push    cs
                pop     es
                ret

dos_function    endp

;-----------------------------------------------------------------
;si = string di = string size es:bx = pointer to buffer to search
;ax = number of bytes in buffer to search. Zero flag set if found
;-----------------------------------------------------------------
SEARCH          PROC    NEAR            ;si points at string
                PUSH    BX
                PUSH    DI
                PUSH    SI
                XCHG    BX,DI           ;string size, ptr to data area
                MOV     CX,AX           ;# chars in segment to search
BYTE_ADD:
                LODSB                   ;char for first part of search
NEXT_SRCH:
                REPNZ   SCASB           ;is first char in string in buffer
                JNZ     NOT_FOUND       ;if not, no match
                PUSH    DI              ;save against cmpsb


                                   ;Page 20



                PUSH    SI
                PUSH    CX
                LEA     CX,[BX-1]       ;# chars in string - 1
                JCXZ    ONE_CHAR        ;if one char search, we have found it
                REP     CMPSB           ;otherwise compare rest of string
ONE_CHAR:
                POP     CX              ;restore for next cmpsb
                POP     SI
                POP     DI
                JNZ     NEXT_SRCH       ;if zr = 0 then string not found
NOT_FOUND:
                 LEA    AX,[DI-1]       ;ptr to last first character found
                 POP    SI
                 POP    DI
                 POP    BX
                 RET                    ;that's all
SEARCH ENDP

cseg            ends
                end     int_test







































                                   ;Page 21



~

                      How to call DOS from within a TSR


                               by David O'Riva


          Just a few ramblings on interactions between TSRs & DOS.


             Cardinal rule:  DON'T CALL DOS UNLESS YOU'RE SURE OF THE
                             MACHINE STATE!!!

          There are a few interrupt calls and memory locations you can
     play with to get this information.  A list & explanation of sorts is
     below.  The reason you don't call DOS if you've interrupted the
     machine in the middle of DOS is that:

             1.  The stack is unstable as far as DOS is concerned, and
                 you'll probably end up overwriting DOS data or going
                 into the weeds.

             2.  DOS only keeps one copy of certain crucial information
                 as it processes a disk-related request.  i.e.  BPB's,
                 current sectors, FAT memory images, fun stuff like that.
                 If you interrupt it in the middle, ask for something
                 different, then go back, you will probably destroy your
                 disk, possibly beyond recall.

             3.  DOS simply was not designed to be re-entrant.  The first
                 9 or 10 function calls are cool most of the time, the
                 rest are strictly single-processing-stream functions.

          However, there is hope.  And, (extra bonus) it happens to be
     compatible with most true MS-DOS releases, and many, many brand-name
     DOSes.  As well as most clones.

          What you need to do is after determining that the user wants to
     pop your program up, you set a few flags.  One of them prevents your
     program from being popped up AGAIN while the current DOS call is
     completing, and the other tells a timer trap routine to start
     looking for DOS to finish it's current process (usually a matter of
     split seconds).  When the timer routine detects that DOS is no
     longer active, it grabs control of the system and runs your TSR.

          At this point, all DOS calls are as safe as they are for a
     normal application.

          What follows is an outline of the code necessary to activate a
     TSR that uses DOS calls.  Depending on the TSR, other things may
     need to be done in these routines as well.  Definitely make sure you
     understand the interactions of the various routines before TSRing
     your background disk formatter.

             Okay, nitty-gritty time...



                                   ;Page 22



             You need 5 main chunks of code to do this right:

                     a) a bit of extra initialization code

                     b) your TSR's main program

                     c) activation request server (usually a keypress
                     trap)

                     d) timer tick inDOS monitor

                     e) DOS busy loop monitor

             And here's what they do:

             a) asks DOS for the location of the inDOS flag, and stores
                that away.

             b) does whatever you want it to.

             c) when the activation requirement is sensed (the user
                pressed the hot-key, the print buffer is empty, the modem
                is sending another packet, whatever) the following steps
                need to be taken:  1. have we already tried to activate,
                     and are waiting for DOS to finish?  if so, then
                        ignore the activation request.

                     2. check the inDOS flag.  if we're not in DOS, then
                        activate as usual.

                     3. set a flag indicating that the TSR wants to
                        activate, but can't right now

                     4. return to DOS

             d) this is linked in AFTER interrupt 08 - that is, when this
                interrupt happens, call the original INT 08 handler, then
                run your checking code:

                     1. does the TSR want to run?  if not, return from the
                        interrupt.

                     2. check the inDOS flag.  If it's out of DOS, then
                        run your code as normal

                     3. return from the interrupt

           * * NOTE: This code has to run FAST.  If it's poorly coded,
                     you may very well see downgraded performance of the
                     entire system.


             e) link in to the DOS keyboard busy loop - INT 28.  This
                     interrupt is called when DOS is waiting for a
                keystroke via functions 1,3,7,8,0A, and 0C.  If the TSR
                takes control from this loop, then DOS functions ABOVE 0C
                are safe to use.  Functions 0 - 0C are NOT safe to use.


                                   ;Page 23



                     1. Does the TSR want to run?  if not, continue down
                        the interrupt chain.

                     2. run the TSR as usual

                     3. continue down the interrupt chain.



          NOTES:  The first action your main TSR code should take is to
             clear the flag that indicates the TSR is trying to run.  If
             this is not done, your TSR will re-enter itself at least
             18.2 times per second... i.e. a MESS.

             The last action your main TSR code should take before
             leaving is to RESET the flags that prevent the TSR from
             being activated.  If you forget to do this, your TSR will
             run once, then never again...  I know from personal
             experience that this is frustrating to a dangerous degree.

             Some of this code is really complicated, so don't get
             discouraged if it takes a few days of tweaking and
             hair-pulling to get it right.

             All numbers in this text are in hex.

             The timer tick routine is really touchy, at least the way I
             wrote it.  Be very sure yours is reliable if you distribute
             a program with this structure.

             The reason that functions 0-0C are separated from the rest
             of the DOS calls as far as re-entrancy is concerned is that
             they use an entirely separate stack frame.  I believe this
             must have been done specifically for the purpose of helping
             TSR writers.

             Does anyone know why the hell Microsoft built these neat
             functions into DOS and then refused to acknowledge their
             existence?



                            INTERRUPT & FUNCTION CALLS

     INT 08
             Timer tick interrupt.  Called 18.2 times a second on IRQ 0.
             The interrupt is triggered by timer 0.


     INT 21, FUNCTION 34

             inDOS flag address request.  This function returns the
             address of the "inDOS flag" as a 32 bit pointer in ES:BX.
             The inDOS flag is a byte that is zero when DOS is not
             processing a function request, and is non-zero when DOS is
             in a function.



                                   ;Page 24



             NOTE: This function is officially specified as RESERVED.
             It's use could change in future versions of DOS, and it can
             only be guaranteed to work in straight IBM PC-DOS or MS-DOS
             versions 2.0 to 3.30.  Use at your own risk.

     INT 28

             DOS keyboard busy loop. This interrupt is called when DOS is
             waiting for a keystroke in the console input functions.
             When this interrupt is issued, it is safe to use any DOS
             call ABOVE 0C.  Calls to DOS functions 0 - 0C will trash the
             stack and do nasty things.

             NOTE: This function is officially RESERVED.  See the note
             for function 34 above.




          AUTHOR'S NOTE:

             First, the references I listed are really great.  They've
          helped me out a lot over the past few years.  Second, if your
          hard disk gets munched by your TSR, read the disclaimer.


           ! ! ! ! ! !   C A V E A T   P R O G R A M M E R   ! ! ! ! ! !

                                 & Disclaimer

          The techniques described in here are, for the most part,
     UNDOCUMENTED by Microsoft or IBM.  This means that you CAN NOT BE
     SURE that they will work on all IBM clones, and could even cause
     crashes on some!  The timer tick interrupt provides some essential
     system services, and messing with it incautiously can wreak havoc.

          The program outlines presented here are what worked for me on
     my system, and what should work on about 90% of the clones out
     there.  However, I still suggest that you find a reference for all
     of the interrupts and functions described here.  This file is meant
     to be a guideline and aid only.


     REFERENCES:

             DOS Programmer's Reference, by Terry R. Dettmann.
                     $22.95, QUE Corporation

             IBM DOS Technical Reference, version 3.30
                     $(?), International Business Machines Corp.

                     I can't remember how much it cost...







                                   ;Page 25



                  Environment Variable Processor
                          by David O'Riva
~
                PAGE    60,132
                TITLE   Q43.ASM - editor prelude & display manager
;
;
COMMENT~***********************************************************************
*   ---===> All code in this file is copyright 1989 by David O'Riva <===---   *
*******************************************************************************
*                                                                             *
* The above line is there only to prevent people (or COMPANIIES) from         *
* claiming original authorship of this code and suing me for using it.        *
* You're welcome to use it anyhow you care to.                                *
*                                                                             *
*
* Environment Variable Finder & Processor -                                   *
*                                                                             *
*       The "get_environment_variable" routine is complete in itself, and can *
* be extracted and used in anything else that needs one.  Just copy the entire
* routine, from the header to the endp (don't forget the RADIX and DW).
* Theroutine currently uses 315 (decimal) bytes.
*
*
*       This program's purposeis to invoke an editor (or any program, really,
* with a specific machine state depending on environment variables. (Yeah!!!)
* Currently it is set up to change my screen to one of various modes, with
* the variable ED_SCRMODE being set to:
*               100/75  = 100 columns by 75 lines
*               132/44  = 132 by 44
*               80/44   = 80 by 44
*       ...and then to EXEC my editor (qedit) with that mode set.  You could
* set the screen back to the standard 80x25 after the EXEC returns.
*
*       Note: The 80/44 set code should work on most (ar all?) EGAs.  The
* other two high-res text modes use built-in extended BIOS modes in my
* Everex EV-657 EGA card (the 800x600 version) w/multisync monitor.  If you've
* got one of those, you're in luck - no mods needed.  It will also work on the
* EV-673 EVGA card w/appropriate monitor.
*
*
*       Note to BEGINNERS: This is not an example of "good" asm code.  This
* file is an example of what happens when you're up at 1:00am with too much
* coffee and a utility that needs to be fixed.
*
*
*
*       This is a COM program, not an EXE.  Remember to use EXE2BIN.
*
*
*
******************************************************************************~
; ; TRUE            EQU     0FFH FALSE           EQU     0 ;
;******************************************************************************
; CODE         SEGMENT PARA PUBLIC 'CODE' ASSUME
                CS:CODE,DS:CODE,ES:CODE,SS:CODE ; MAIN            PROC    NEAR



                                   ;Page 26



                ORG     100H
entry:
;------------------------------------------------------------------------------
; set the screen to the correct mode
;------------------------------------------------------------------------------

                call    set_screen_mode

;------------------------------------------------------------------------------
; check for pathname change in environment
;------------------------------------------------------------------------------

                call    set_exec_name

;------------------------------------------------------------------------------
; setup memory and run the program
;------------------------------------------------------------------------------
                MOV     BX,OFFSET ENDRESIDENT   ;deallocate unnecessary memory
                MOV     CL,4
                SHR     BX,CL
                INC     BX
                MOV     AH,04AH
                INT     021H

                MOV     AX,CS                   ;exec the program
                MOV     INSERT_CS1,AX
                MOV     INSERT_CS2,AX
                MOV     INSERT_CS3,AX
                MOV     AX,04B00H
                MOV     BX,OFFSET EXECPARMS
                MOV     DX,OFFSET PROGNAME
                INT     021H
;------------------------------------------------------------------------------
; clean up and leave
;------------------------------------------------------------------------------
                MOV     AH,04DH                 ;get return code from program
                INT     021H

                MOV     AH,04CH                 ;leave
                INT     021H
;
;******************************************************************************
;
; data
;
PROGNAME        DB      'F:\UTILITY\MISC\Q.EXE',0
                db      100 dup(' ')


EXECPARMS       DW      0               ;use current environment
                DW      080H            ;use current command tail
INSERT_CS1      DW      ?
                DW      05CH            ;use current FCB's
INSERT_CS2      DW      ?
                DW      06CH
INSERT_CS3      DW      ?



                                   ;Page 27



ENDRESIDENT:

;******************************************************************************
; more data - used only for setup & checks
;
valid_modes     db      '80/44 '
                db      '132/44'
                db      '100/75'
screen_mode     db      '      '

mode_jump       dw      goto_43
                dw      goto_132
                dw      goto_100


ev_mode         db      'ED_SCRMODE',0
ev_pathname     db      'ED_PATH',0



                PAGE
;******************************************************************************
; set_screen_mode -
;
;
;     ENTRY:
;
;      EXIT:
;
; DESTROYED:
;
;------------------------------------------------------------------------------
set_screen_mode:
                MOV     AH,012H                 ;check for presence of EGA/VGA
                MOV     BL,010H
                INT     010H
                CMP     BL,010H                 ;BL changed? (should have # of
                                                ;  bytes of EGA memory)
                JE      ssm_no_ega              ;This is no EGA!
;------------------------------------------------------------------------------
; check environment for correct mode set -
;       don't set mode if none specified
;------------------------------------------------------------------------------
                mov     si,offset ev_mode
                mov     di,offset screen_mode
                mov     cx,6                    ;accept 6 chars
                mov     ax,4                    ;get fixed-length string
                call    get_environment_variable

                and     ax,0feh
                jne     ssm_no_env_mode
;------------------------------------------------------------------------------
; look up the variable's value in my mode table
;------------------------------------------------------------------------------
                mov     bx,0
                mov     di,offset valid_modes



                                   ;Page 28



ssm_check_mode: mov     dx,di
                mov     si,offset screen_mode
                mov     cx,6
                repe    cmpsb
                je      ssm_found_mode
                mov     di,dx
                add     di,6
                inc     bx
                cmp     bx,3
                jne     ssm_check_mode
                jmp     ssm_bad_mode
;------------------------------------------------------------------------------
; set the correct screen mode
;------------------------------------------------------------------------------
ssm_found_mode: shl     bx,1
                jmp     mode_jump[bx]

goto_100:       mov     ax,0070h
                mov     bx,8
                int     010h
                jmp     ssm_leave

goto_132:       mov     ax,0070h
                mov     bx,0bh
                int     010h
                jmp     ssm_leave


goto_43:        MOV     AX,3
                INT     010H
                MOV     AX,01112H               ;set to 8x8 chars (43/50 lines)
                MOV     BL,0
                INT     010H
ssm_no_env_mode:
ssm_bad_mode:
ssm_no_ega:
ssm_leave:
                ret



                PAGE
;******************************************************************************
; set_exec_name -
;
;
;     ENTRY:
;
;      EXIT:
;
; DESTROYED:
;
;------------------------------------------------------------------------------
set_exec_name:
;
;       If you want, write a chunk here that will read an alternate pathname
; for the editor to be executed from a different variable (like ED_PATH)


                                   ;Page 29



; I was going to do it, but ran out of time and need. (My editor never wanders
; around!)
;
                ret









                PAGE
;******************************************************************************
; Get_environment_variable -
;
;
;
;
;     ENTRY:    ds:[si] -> ASCIIZ environment variable name
;               ds:[di] -> (up to) 129 byte buffer for string
;               es = segment of program's PSP
;               cx = maximum # of characters to accept
;               al = variable return format
;                 0 - return string in ASCIIZ format
;                       xxxxx 0 ........
;
;                 1 - return string in DOS string ('$' terminated) format
;                       xxxxxxxx $ ........
;
;                 2 - return string in DOS input buffer format
;                       maxchrs,numchrs,xxxxxxxx CR ............
;
;                 3 - return string in command tail format
;                       numchrs,xxxxxxxxxxx CR ..........
;
;                 4 - return string in fixed-length (CX chars) format
;                       xxxxxx
;
;      EXIT:    al = return codes:
;                   bit 0 - if set, string was longer than max, truncated
;                       1 - if set, string did not exist
;                       2 - if set, invalid return format requested
;
; DESTROYED:    ah is undefined
;
;------------------------------------------------------------------------------
.RADIX 010h
gev_flags       dw      ?

Get_environment_variable:

                push    bx
                push    cx
                push    dx
                push    si


                                   ;Page 30



                push    di
                push    es

                mov     cs:gev_flags,ax
                mov     es,es:[02c]             ;es -> program's environment
;------------------------------------------------------------------------------
; make sure the environment has at least one variable in it
;------------------------------------------------------------------------------
                mov     ax,es:[0]
                cmp     ax,0
                jne     gev_exists
                mov     ax,2
                jmp     gev_leave
;------------------------------------------------------------------------------
; find length of search string
;------------------------------------------------------------------------------
gev_exists:     push    cx
                push    di
                mov     di,si
                mov     cx,0ffff
gev_sourcelen:
                inc     cx
                mov     al,[di]
                inc     di
                cmp     al,0
                jne     gev_sourcelen

                cmp     cx,0
                jne     gev_startfind

                pop     di
                pop     cx
                mov     ax,2
                jmp     gev_leave
;------------------------------------------------------------------------------
; find string
;------------------------------------------------------------------------------
gev_startfind:  mov     bx,cx
                mov     dx,si
                mov     di,0
gev_checknext:
                mov     cx,bx
                mov     si,dx
                repe    cmpsb
                je      gev_found?

gev_tonextvar:  mov     cx,0ffff
                mov     al,0
                repne   scasb

                cmp     es:[di],al
                jne     gev_checknext

                mov     ax,2
                pop     di
                pop     cx
                jmp     gev_leave


                                   ;Page 31



gev_found?:     cmp     byte ptr es:[di],'='
                jne     gev_tonextvar
;------------------------------------------------------------------------------
; found the string in the environment
;------------------------------------------------------------------------------
gev_found:      inc     di
                mov     si,di
                pop     di
                pop     cx
                cmp     cs:gev_flags,1
                ja      gev_ibufform
;------------------------------------------------------------------------------
; move normal string with 0 or $ terminator
;------------------------------------------------------------------------------
gev_nextchar0:  mov     al,es:[si]
                cmp     al,0
                je      gev_setterm0
                mov     ds:[di],al
                inc     si
                inc     di
                dec     cx
                jne     gev_nextchar0
                mov     al,es:[si]
                cmp     al,0
                je      gev_setterm0
                mov     al,1

gev_setterm0:   cmp     cs:gev_flags,0
                jne     gev_setterm1
                mov     byte ptr ds:[di],0              ;ASCIIZ string
                jmp     gev_leave

gev_setterm1:   mov     byte ptr ds:[di],'$'            ;DOS string
                jmp     gev_leave
;------------------------------------------------------------------------------
; move string into DOS input buffer format (int 21 function 0A)
;------------------------------------------------------------------------------
gev_ibufform:   cmp     cs:gev_flags,2
                jne     gev_ctailform

                mov     ds:[di],cl                      ;set max length
                inc     di
                mov     bx,di
                inc     di
                mov     dx,0

gev_nextchar2:  mov     al,es:[si]
                cmp     al,0
                je      gev_setterm2
                mov     ds:[di],al
                inc     si
                inc     di
                inc     dx
                dec     cx
                jne     gev_nextchar2
                mov     al,es:[si]
                cmp     al,0


                                   ;Page 32



                je      gev_setterm2
                mov     al,1

gev_setterm2:   mov     byte ptr ds:[di],0d             ;add carriage return
                mov     ds:[bx],dl                      ;set actual # of chars
                jmp     gev_leave
;------------------------------------------------------------------------------
; move string into command tail format
;------------------------------------------------------------------------------
gev_ctailform:  cmp     cs:gev_flags,3
                jne     gev_fixedform

                mov     bx,di
                inc     di
                mov     dx,0

gev_nextchar3:  mov     al,es:[si]
                cmp     al,0
                je      gev_setterm3
                mov     ds:[di],al
                inc     si
                inc     di
                inc     dx
                dec     cx
                jne     gev_nextchar3
                mov     al,es:[si]
                cmp     al,0
                je      gev_setterm3
                mov     al,1

gev_setterm3:   mov     byte ptr ds:[di],0d             ;set carriage return
                mov     ds:[bx],dl                      ;set # of bytes
                jmp     gev_leave
;------------------------------------------------------------------------------
; move string into fixed-length area (pad it out with spaces)
;------------------------------------------------------------------------------
gev_fixedform:  cmp     cs:gev_flags,4
                jne     gev_badform

gev_nextchar4:  mov     al,es:[si]
                cmp     al,0
                je      gev_padout4
                mov     ds:[di],al
                inc     si
                inc     di
                dec     cx
                jne     gev_nextchar4
                mov     al,es:[si]
                cmp     al,0
                je      gev_setterm4
                mov     al,1
                jmp     gev_setterm4

gev_padout4:    mov     byte ptr ds:[di],' '
                inc     di
                dec     cx
                jne     gev_padout4


                                   ;Page 33



                mov     al,0
gev_setterm4:   jmp     gev_leave


gev_badform:    mov     ax,4

gev_leave:      pop     es
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx
                ret
.RADIX 00ah


MAIN            ENDP
;
;******************************************************************************
;
CODE            ENDS
;
;******************************************************************************
;
          END  ENTRY

~
































                                   ;Page 34



                             Program Reviews


     Multi-Edit ver 4.00a (demo version): Reviewed by Patrick O'Riva.

          Multi-Edit is a high feature text editor with many word
     processor features. The demo version is completely functional though
     some of the reference material is not supplied and there are
     advertising screens. I consider this fully acceptable as shareware.
     The complete version with the macro reference library is available
     for 79.95 and an expanded version with a spelling checker,
     integrated Communication terminal and phone book is $179.95.

          I couldn't list all of its features here, but in addition to
     everything you have come to expect in a quality programming editor
     (multi meg files, programmable keyboard etc.) there are a number of
     powerful additions you might not expect. The word processor
     functions rival most of the specialty ones that I've tried. It
     won't compete with the major names for those of you who are addicted
     to them, but it does offer full printer support, preview file, table
     of contents generation, and extension keyed formatting. It will
     right or left justify, and supports headers and footers, and auto
     pagination.

          It contains a calculator and an Ascii table

          Saving the best for last: The language support is very strong.
     It has built in templates for many common constructs, and the
     assembler/compiler is invoked from within the editor with a single
     key. It will read the error table generated by a variety of software
     and with successive key presses move you to each line where an error
     was found.

          Something which I found unique is Multi-Edit's help system.  It
     is a hypertext system, and is wonderfully context sensitive most
     everywhere in the system. From the Help menu it has a complete table
     of contents and index. It is also fully user extendible. I have
     integrated a database I have documenting the full set of interrupts
     that totals about 400k and the documentation on my spelling checker
     as well (which integrated into Multi-Edit almost seamlessly).

          In many ways this is the best editor I've ever used, but it
     does have a few faults, some of which are very subtle and may not
     even be problems to most users.  It is a 'tad' slower that what I'm
     used to with Qedit.  This is seldom noticed except in the execution
     of complex macros.  It is quite slow in paging through long files.
     There are some true bugs in this version such as a crash of the
     program (but not the data or the system) when large deletes from
     large files are made. Multi-edit's treatment of file windows while
     very versatile is slightly different and may take some time to get
     used to.

          For all of its advantages, until putting this Magazine
     together, I still found myself reverting to Qedit for the speed and
     ease of use.  It is the first software that has made this anything
     other than an exercise in frustration.



                                   ;Page 35



     SHEZ

          Just a quick mention because it isn't programming related.
     Shez is a compression shell along the lines of ArcMaster and Qfiler.
     It is a fine and versatile piece of programming, supporting all
     common compression types. The more recent versions have virus
     detection when used with the SCANV programs by John McAfee.



      4DOS

          This is a program that is an absolute joy to use.  It is a
     complete and virtually 100% compatible replacement for Command.com.
     The code size is just slightly larger than MSDOS 3.3 command.com but
     the added and enhanced functions save many times that amount in
     TSR's you no longer need to install. Just to mention a few features:
     An   alias  command whereby you can assign whatever mnemonic you
     wish to a command or string of commands. Select  is a screen
     interface that allows you to mark files for use with a command.
     Except   will execute a command for a set of files excluding one or
     more. There is an environment editor, built in Help, command
     and filename completion, Global that will execute through the
     directory tree, A Timer to keep track of elapsed time, as well as
     many enhanced batch file commands. Additional features are too
     numerous to mention. The current version is 4.23 and is available as
     Shareware, but you should register after your first 10 minutes of
     use. You will be hooked forever.


     The above 3 programs should all be available on your local BBS's.
     Please be sure and register programs you use.



























                                   ;Page 36



                                Book Reviews


     Assembly Language Quick Reference

          by Allen L. Wyatt, Sr.
          Reviewed by George A. Stanislav

     This 1989 book published by QUE is a nice and handy reference for
     assembly language programmers.

     Instruction sets for six microprocessors and numeric coprocessors
     are listed:

             8086/8088       8087
             80286           80287
             80386           80387

     I could find no reference to the 80186 microprocessor, not even a
     suggestion that it uses the 80286 instruction set but does not
     multitask. Because the 80186 was the brain of Tandy 2000, quite a
     popular computer in its own time, its omission from the book is
     surprising.

     There is no division into chapters. This makes it somewhat hard to
     figure out where the instruction sets of individual processors
     start. Each higher processor set contains only the list of
     instructions that are new for the processor or that changed
     somewhat.

     After a  brief introduction, the book starts by listing,
     alphabetically, all 8086/8088 instructions. The listing itself is
     very well done. Each instruction stands out graphically from the
     rest of the text. For every code there is some classification, e.g.
     arithmetic, bit manipulation, data-transfer.

     This is followed by a very brief description ended with a colon.
     Next, a more detailed explanation gives sufficient information to
     any assembly language programmer what the instruction does.

     If applicable, the book lists flags affected by the instruction.
     Most instructions also contain some coding examples.

     The 8086/8088 instruction set is followed by the 80286 set, or
     rather subset as it only contains the instructions new to this
     microprocessor. Similarly, the 80386 section contains only those
     instructions not found in the 8086/8088 and 80286 sections as well
     as those that changed somewhat.

     I find it puzzling that among those instructions considered changed
     in the 80386 microprocessor we can find AND, NEG, POP - because they
     can be used as 32-bit instructions in addition to their original
     usage - but cannot find JE, JNE, and all other conditional jumps.
     These did indeed change in the 80386 processor inasmuch they can be
     used either as SHORT or as NEAR while on the older microprocessors
     they could only jump within the SHORT range.



                                   ;Page 37



     The rest of the book contains instructions for the math
     coprocessors, the 8087, 80287 and 80387. This section is divided in
     the same way as the microprocessor part, i.e. describing first the
     8087 set, then the one new instruction for the 80286, followed by
     the new 80387 instructions.

     There are several possibilities of improvement QUE might consider
     for future editions of this book:

             o Make it easier to find the start of each section by color
               coding the side of the paper;

             o Include references to the instructions of the older
               processors within the listing for the new processors.
               Small print of the instruction with the page number where
               a more detailed description can be found would be a nice
               enhancement;

             o At least a brief mention of the 80186 microprocessor and
               perhaps the V-20 and V-30 would be useful.

     Despite the possibility of improvement, this is an excellent
     reference for any assembly language programmer. Its small size makes
     it very handy to keep it next to the computer as well as to take it
     along when travelling.

     The book costs $6.95 in USA and $8.95 in Canada.
































                                   ;Page 38



                             GPFILT.ASM
 ~
        page    ,132
        TITLE   GPFILT
        subttl  General Purpose Filter Template
;
; GPFILT.ASM
; This file contains a template for a general-purpose assembly language
; filter program.
;
; Fill in the blanks for what you wish to do.  The program is set up to
; accept a command line in the form:
;       COMMAND [{-|/}options] [infile [outfile]]
;
; If infile is not specified, stdin is used.
; If outfile is not specified, stdout is used.
;
; To compile and link:
;    MASM GPFILT ;
;    LINK GPFILT ;
;    EXE2BIN GPFILT GPFILT.COM
;
; Standard routines supplied in the general shell are:
;
; get_arg - returns the address of the next command line argument in
;           DX.  Since this is a .COM file, the routine assumes DS will
;           be the same as the command line segment.
;           The routine will return with Carry set when it reaches the end
;           of the command line.
;
; err_msg - displays an ASCIIZ string on the STDERR device.  Call with the
;           address of the string in ES:DX.
;
; do_usage- displays the usage message on the STDERR device and exits
;           with an error condition (errorlevel 1).  This routine will
;           never return.
;
; getch   - returns the next character from the input stream in AL.
;           It will return with carry set if an error occurs during read.
;           It will return with the ZF set at end of file.
;
; putch   - writes a character from AL to the output stream.  Returns with
;           carry set if a write error occurs.
;
cseg    segment
        assume cs:cseg, ds:cseg, es:cseg, ss:cseg

        org     0100h                   ;for .COM files

start:  jmp     main                    ;jump around data area

;
; Equates and global data area.
;
; The following equates and data areas are required by the general filter
; routines.  User data area follows.
;


                                   ;Page 39



STDIN   equ     0
STDOUT  equ     1
STDERR  equ     2
STDPRN  equ     3
cr      equ     0dh
lf      equ     0ah
space   equ     32
tab     equ     9

infile  dw      STDIN                   ;default input file is stdin
outfile dw      STDOUT                  ;default output file is stdout
errfile dw      STDERR                  ;default error file is stderr
prnfile dw      STDPRN                  ;default print file is stdprn
cmd_ptr dw      0081h                   ;address of first byte of command tail
PSP_ENV equ     002ch                   ;The segment address of the environment
                                        ;block is stored here.

infile_err      db      cr, lf, 'Error opening input file', 0
outfile_err     db      cr, lf, 'Error opening output file', 0
aborted         db      07, cr, lf, 'Program aborted', 0
usage           db      cr, lf, 'Usage: ', 0
crlf            db      cr, lf, 0

;************************************************************************
;*                                                                      *
;* Buffer sizes for input and output files.  The buffers need not be    *
;* the same size.  For example, a program that removes tabs from a text *
;* file will output more characters than it reads.  Therefore, the      *
;* output buffer should be slightly larger than the input buffer.  In   *
;* general, the larger the buffer, the faster the program will run.     *
;*                                                                      *
;* The only restriction here is that the combined size of the buffers   *
;* plus the program code and data size cannot exceed 64K.               *
;*                                                                      *
;* The easiest way to determine maximum available buffer memory is to   *
;* assemble the program with minimum buffer sizes and examine the value *
;* of the endcode variable at the end of the program.  Subtracting this *
;* value from 65,536 will give you the total buffer memory available.   *
;*                                                                      *
;************************************************************************
;
INNBUF_SIZE     equ     31              ;size of input buffer (in K)
OUTBUF_SIZE     equ     31              ;size of output buffer (in K)

;
;************************************************************************
;*                                                                      *
;* Data definitions for input and output buffers.  DO NOT modify these  *
;* definitions unless you know exactly what it is you're doing!       *
;*                                                                      *
;************************************************************************
;
; Input buffer
ibfsz   equ     1024*INNBUF_SIZE        ;input buffer size in bytes
inbuf   equ     endcode                 ;input buffer
ibfend  equ     inbuf + ibfsz           ;end of input buffer
;


                                   ;Page 40



; ibfptr is initialized to point past end of input buffer so that the first
; call to getch will result in a read from the file.
;
ibfptr  dw      inbuf+ibfsz

; output buffer
obfsz   equ     1024*OUTBUF_SIZE        ;output buffer size in bytes
outbuf  equ     ibfend                  ;output buffer
obfend  equ     outbuf + obfsz          ;end of output buffer
obfptr  dw      outbuf                  ;start at beginning of buffer

;************************************************************************
;*                                                                      *
;*                            USER DATA AREA                            *
;*                                                                      *
;*      Insert any data declarations specific to your program here.     *
;*                                                                      *
;* NOTE:  The prog_name, use_msg, and use_msg1 variables MUST be        *
;*        defined.                                                      *
;*                                                                      *
;************************************************************************
;
; This is the program name.  Under DOS 3.x, this is not used because we
; can get the program name from the environment.  Prior to 3.0, this
; information is not supplied by the OS.
;
prog_name       db      'GPFILT', 0
;
; This is the usage message.  The first two lines are required.
; The first line is the programs title line.
;   Make sure to include the 0 at the end of the first line!!
; The second line shows the syntax of the program.
; Following lines (which are optional), are discussion of options, features,
; etc...
; The message MUST be terminated by a 0.
;
use_msg db      ' - General Purpose FILTer program.', cr, lf, 0
use_msg1        label byte
        db      '[{-|/}options] [infile [outfile]]', cr, lf
        db      cr, lf
        db      'If infile is not specified, STDIN is used', cr, lf
        db      'If outfile is not specified, STDOUT is used', cr, lf
        db      0
;
;************************************************************************
;*                                                                      *
;* The main routine parses the command line arguments, opens files, and *
;* does other initialization tasks before calling the filter procedure  *
;* to do the actual work.                                               *
;* For a large number of filter programs, this routine will not need to *
;* be modified.  Options are parsed in the get_options proc., and the   *
;* filter proc. does all of the 'filter' work.                          *
;*                                                                      *
;************************************************************************
;
main:   cld
        call    get_options             ;process options


                                   ;Page 41



        jc      gofilter                ;carry indicates end of arg list
        mov     ah,3dh                  ;open file
        mov     al,0                    ;read access
        int     21h                     ;open the file
        mov     word ptr ds:[infile], ax ;save file handle
        jnc     main1                   ;carry clear indicates success
        mov     dx,offset infile_err
        jmp     short err_exit
main1:  call    get_arg                 ;get cmd line arg in DX
        jc      gofilter                ;carry indicates end of arg list
        mov     ah,3ch                  ;create file
        mov     cx,0                    ;normal file
        int     21h                     ;open the file
        mov     word ptr ds:[outfile],ax ;save file handle
        jnc     gofilter                ;carry clear indicates success
        mov     dx,offset outfile_err
        jmp     short err_exit
gofilter:
        call    filter                  ;do the work
        jc      err_exit                ;exit immediately on error
        mov     ah,3eh
        mov     bx,word ptr [infile]
        int     21h                     ;close input file
        mov     ah,3eh
        mov     bx,word ptr [outfile]
        int     21h                     ;close output file
        mov     ax,4c00h
        int     21h                     ;exit with no error
err_exit:
        call    err_msg                 ;output error message
        mov     dx,offset aborted
        call    err_msg
        mov     ax,4c01h
        int     21h                     ;and exit with error
;
;************************************************************************
;*                                                                      *
;* get_options processes any command line options.  Options are         *
;* preceeded by either - or /.  There is a lot of flexibility here.     *
;* Options can be specified separately, or as a group.  For example,    *
;* the command "GPFILT -x -y -z" is equivalent to "GPFILT -xyz".        *
;*                                                                      *
;* This routine MUST return the address of the next argument in DX or   *
;* carry flag set if there are no more options.  In other words, return *
;* what was returned by the last call to get_arg.                       *
;*                                                                      *
;************************************************************************
;
get_options     proc
        call    get_arg                 ;get command line arg
        jnc     opt1
; If at least one argument is required, use this line
;       call    do_usage                ;displays usage msg and exits
; If there are no required args, use this line
        ret                             ;if no args, just return
opt1:   mov     di, dx
        mov     al,byte ptr ds:[di]


                                   ;Page 42



        cmp     al,'-'                  ;if first character of arg is '-'
        jz      opt_parse
        cmp     al,'/'                  ;or '/', then get options
        jz      opt_parse
        ret                             ;otherwise exit
opt_parse:
        inc     di
        mov     al,byte ptr ds:[di]
        or      al,al                   ;if end of options string
        jz      nxt_opt                 ;get cmd. line arg
        cmp     al,'?'                  ;question means show usage info
        jz      do_usage
;
;************************************************************************
;*                                                                      *
;* Code for processing other options goes here.  The current option     *
;* character is in AL, and the remainder of the option string is pointed*
;* to by DS:DI.                                                         *
;*                                                                      *
;************************************************************************
;
        jmp     short opt_parse

nxt_opt:
        call    get_arg                 ;get next command line arg
        jnc     opt1                    ;if carry
vld_args:                               ;then validate arguments
;
;************************************************************************
;*                                                                      *
;* Validate arguments.  If some options are mutually exclusive/dependent*
;* use this area to validate them.  Whatever the case, if you must      *
;* abort the program, call the do_usage procedure to display the usage  *
;* message and exit the program.                                        *
;*                                                                      *
;************************************************************************
;
        ret                             ; no more options
;
;************************************************************************
;*                                                                      *
;* Filter does all the work.  Modify this routine to do what it is you  *
;* need done.                                                           *
;*                                                                      *
;************************************************************************
;
filter  proc
        call    getch                   ;get a character from input into AL
        jbe     filt_done               ;exit on error or EOF
        and     al, 7fh                 ;strip the high bit
        call    putch                   ;and output it
        jc      filt_ret                ;exit on error
        jmp     short filter
filt_done:
        jc      filt_ret                ;carry set is error
        call    write_buffer            ;output what remains of the buffer
filt_ret:


                                   ;Page 43



        ret
filter  endp
;
;************************************************************************
;*                                                                      *
;*              Put any program-specific routines here                  *
;*                                                                      *
;************************************************************************

;
;************************************************************************
;*                                                                      *
;* For most programs, nothing beyond here should require modification.  *
;* The routines that follow are standard routines used by almost every  *
;* filter program.                                                      *
;*                                                                      *
;************************************************************************
;
;************************************************************************
;*                                                                      *
;* This routine outputs the usage message to the STDERR device and      *
;* aborts the program with an error code.  A little processing is done  *
;* here to get the program name and format the output.                  *
;*                                                                      *
;************************************************************************
;
do_usage:
        mov     dx, offset crlf
        call    err_msg                 ;output newline
        mov     ah,30h                  ;get DOS version number
        int     21h
        sub     al,3                    ;check for version 3.x
        jc      lt3                     ;if carry, earlier than 3.0
;
; For DOS 3.0 and later the full pathname of the file used to load this
; program is stored at the end of the environment block.  We first scan
; all of the environment strings in order to find the end of the env, then
; scan the load pathname looking for the file name.
;
        push    es
        mov     ax, word ptr ds:[PSP_ENV]
        mov     es, ax                  ;ES is environment segment address
        mov     di, 0
        mov     cx, 0ffffh              ;this ought to be enuf
        xor     ax, ax
getvar: scasb                           ;get char
        jz      end_env                 ;end of environment
gv1:    repnz   scasb                   ;look for end of variable
        jmp     short getvar            ;and loop 'till end of environment
end_env:
        inc     di
        inc     di                      ;bump past word count
;
; ES:DI is now pointing to the beginning of the pathname used to load the
; program.  We will now scan the filename looking for the last path specifier
; and use THAT address to output the program name.  The program name is
; output WITHOUT the extension.


                                   ;Page 44



;
        mov     dx, di
fnloop: mov     al, byte ptr es:[di]
        or      al, al                  ;if end of name
        jz      do30                    ;then output it
        inc     di
        cmp     al, '\'                 ;if path specifier
        jz      updp                    ;then update path pointer
        cmp     al, '.'                 ;if '.'
        jnz     fnloop
        mov     byte ptr es:[di-1], 0   ;then place a 0 so we don't get ext
        jmp     short fnloop            ; when outputting prog name
updp:   mov     dx, di                  ;store
        jmp     short fnloop
;
; ES:DX now points to the filename of the program loaded (without extension).
; Output the program name and then go on with rest of usage message.
;
do30:   call    err_msg                 ;output program name
        pop     es                      ;restore
        jmp     short gopt3
;
; We arrive here if the current DOS version is earlier than 3.0.  Since the
; loaded program name is not available from the OS, we'll output the name
; entered in the 'prog_name' field above.
;
lt3:    mov     dx, offset prog_name
        call    err_msg                 ;output the program name
;
; After outputting program name, we arrive here to output the rest of the
; usage message.  This code assumes that the usage message has been
; written as specified in the data area.
;
gopt3:  mov     dx, offset use_msg
        call    err_msg                 ;output the message
        mov     dx, offset usage
        call    err_msg
        mov     dx, offset use_msg1
        call    err_msg
        mov     ax,4c01h
        int     21h                     ;and exit with error
get_options     endp

;
;************************************************************************
;*                                                                      *
;* Output a message (ASCIIZ string) to the standard error device.       *
;* Call with address of error message in ES:DX.                         *
;*                                                                      *
;************************************************************************
;
err_msg proc
        cld
        mov     di,dx                   ;string address in di
        mov     cx,0ffffh
        xor     ax,ax
        repnz   scasb                   ;find end of string


                                   ;Page 45



        xor     cx,0ffffh
        dec     cx                      ;CX is string length
        push    ds
        mov     ax,es
        mov     ds,ax                   ;DS is segment address
        mov     ah,40h
        mov     bx,word ptr cs:[errfile]
        int     21h                     ;output message
        pop     ds
        ret
err_msg endp

;
;************************************************************************
;*                                                                      *
;* getch returns the next character from the file in AL.                *
;* Returns carry = 1 on error                                           *
;*         ZF = 1 on EOF                                                *
;* Upon exit, if either Carry or ZF is set, the contents of AL is       *
;* undefined.                                                           *
;*                                                                      *
;************************************************************************
;
; Local variables used by the getch proc.
eof     db      0                       ;set to 1 when EOF reached in read
last_ch dw      ibfend                  ;pointer to last char in buffer

getch   proc
        mov     si,word ptr ds:[ibfptr] ;get input buffer pointer
        cmp     si,word ptr ds:[last_ch];if not at end of buffer
        jz      getch_eob
getch1: lodsb                           ;character in AL
        mov     word ptr ds:[ibfptr],si ;save buffer pointer
        or      ah,1                    ;will clear Z flag
        ret                             ;and done

getch_eob:                              ;end of buffer processing
        cmp     byte ptr ds:[eof], 1    ;end of file?
        jnz     getch_read              ;nope, read file into buffer
getch_eof:
        xor     ax, ax                  ;set Z to indicate EOF
        ret                             ;and return

getch_read:                     ; Read the next buffer full from the file.
        mov     ah,3fh                  ;read file function
        mov     bx,word ptr ds:[infile] ;input file handle
        mov     cx,ibfsz                ;#characters to read
        mov     dx,offset inbuf         ;read into here
        int     21h                     ;DOS'll do it for us
        jc      read_err                ;Carry means error
        or      ax,ax                   ;If AX is zero,
        jz      getch_eof               ;we've reached end-of-file
        add     ax,offset inbuf
        mov     word ptr ds:[last_ch],ax;and save it
        mov     si,offset inbuf
        jmp     short getch1            ;and finish processing character



                                   ;Page 46



read_err:                               ;return with error and...
        mov     dx,offset read_err_msg  ; DX pointing to error message string
        ret
read_err_msg    db      'Read error', cr, lf, 0
getch   endp

;
;************************************************************************
;*                                                                      *
;* putch writes the character passed in AL to the output file.          *
;* Returns carry set on error.  The character in AL is retained.        *
;*                                                                      *
;************************************************************************
;
putch   proc
        mov     di,word ptr ds:[obfptr] ;get output buffer pointer
        stosb                           ;save the character
        mov     word ptr ds:[obfptr],di ;and update buffer pointer
        cmp     di,offset obfend        ;if buffer pointer == buff end
        clc
        jnz     putch_ret
        push    ax
        call    write_buffer            ;then we've got to write the buffer
        pop     ax
putch_ret:
        ret
putch   endp

;
;************************************************************************
;*                                                                      *
;* write_buffer writes the output buffer to the output file.            *
;* This routine should not be called except by the putch proc. and at   *
;* the end of all processing (as demonstrated in the filter proc).      *
;*                                                                      *
;************************************************************************
;
write_buffer    proc                    ;write buffer to output file
        mov     ah, 40h                 ;write to file function
        mov     bx, word ptr ds:[outfile];output file handle
        mov     cx, word ptr ds:[obfptr]
        sub     cx, offset outbuf       ;compute #bytes to write
        mov     dx, offset outbuf       ;from this buffer
        int     21h                     ;DOS'll do it
        jc      write_err               ;carry is error
        or      ax,ax                   ;return value of zero
        jz      putch_full              ;indicates disk full
        mov     word ptr ds:[obfptr],offset outbuf
        clc
        ret

putch_full:                             ;disk is full
        mov     dx,offset disk_full
        stc                             ;exit with error
        ret

write_err:                              ;error occured during write


                                   ;Page 47



        mov     dx,offset write_err_msg
        stc                             ;return with error
        ret
write_err_msg   db      'Write error', cr, lf, 0
disk_full       db      'Disk full', cr, lf, 0

write_buffer    endp

;
;************************************************************************
;*                                                                      *
;* get_arg - Returns the address of the next command line argument in   *
;* DX.  The argument is in the form of an ASCIIZ string.                *
;* Returns Carry = 1 if no more command line arguments.                 *
;* Upon exit, if Carry is set, the contents of DX is undefined.         *
;*                                                                      *
;************************************************************************
;
get_arg proc
        mov     si,word ptr [cmd_ptr]
skip_space:                             ;scan over leading spaces and commas
        lodsb
        cmp     al,0                    ;if we get a null
        jz      sk0
        cmp     al,cr                   ;or a CR,
        jnz     sk1
sk0:    stc                             ;set carry to indicate failure
        ret                             ;and exit
sk1:    cmp     al,space
        jz      skip_space              ;loop until no more spaces
        cmp     al,','
        jz      skip_space              ;or commas
        cmp     al,tab
        jz      skip_space              ;or tabs

        mov     dx,si                   ;start of argument
        dec     dx
get_arg1:
        lodsb                           ;get next character
        cmp     al,cr                   ;argument seperators are CR,
        jz      get_arg2
        cmp     al,space                ;space,
        jz      get_arg2
        cmp     al,','                  ;comma,
        jz      get_arg2
        cmp     al,tab                  ;and tab
        jnz     get_arg1

get_arg2:
        mov     byte ptr ds:[si-1], 0   ;delimit argument with 0
        cmp     al, cr                  ;if char is CR then we've reached
        jnz     ga2                     ; the end of the argument list
        dec     si
ga2:    mov     word ptr ds:[cmd_ptr], si ;save for next time 'round
        ret                             ;and return
get_arg endp



                                   ;Page 48



endcode equ     $

cseg    ends
        end     start
